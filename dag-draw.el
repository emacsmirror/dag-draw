;;; dag-draw.el --- Draw directed graphs using the Gansner-Koutsofios-North-Vo algorithm -*- lexical-binding: t -*-

;; Copyright (C) 2024

;; Author: Generated by Claude
;; Version: 0.1.0
;; Package-Requires: ((emacs "26.1") (dash "2.19.1") (ht "2.3"))
;; Keywords: graphics, visualization, graphs, diagrams
;; URL: https://github.com/example/dag-draw.el

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <https://www.gnu.org/licenses/>.

;;; Commentary:

;; This package implements the directed graph drawing algorithm described in
;; "A Technique for Drawing Directed Graphs" by Gansner, Koutsofios, North,
;; and Vo (1993).  The algorithm consists of four main passes:
;;
;; 1. Rank assignment using network simplex optimization
;; 2. Vertex ordering within ranks to minimize edge crossings
;; 3. Node coordinate positioning
;; 4. Spline edge drawing using BÃ©zier curves
;;
;; The package provides functions to create, manipulate, and render directed
;; graphs in various formats including SVG and ASCII art.

;;; Code:

(require 'dash)
(require 'ht)

;;; Customization

(defgroup dag-draw nil
  "Draw directed graphs using the GKNV algorithm."
  :group 'graphics
  :prefix "dag-draw-")

(defcustom dag-draw-default-node-separation 20
  "Default minimum horizontal separation between nodes."
  :type 'integer
  :group 'dag-draw)

(defcustom dag-draw-default-rank-separation 40
  "Default minimum vertical separation between ranks."
  :type 'integer
  :group 'dag-draw)

(defcustom dag-draw-default-output-format 'svg
  "Default output format for rendered graphs."
  :type '(choice (const :tag "SVG" svg)
                 (const :tag "ASCII" ascii)
                 (const :tag "DOT" dot))
  :group 'dag-draw)

;;; Core Data Structures

(cl-defstruct (dag-draw-node
               (:constructor dag-draw-node-create)
               (:copier nil))
  "A node in a directed graph."
  id                    ; Unique identifier
  label                 ; Display label
  (x-size 80)          ; Width of node bounding box
  (y-size 40)          ; Height of node bounding box
  (x-coord nil)        ; X coordinate (set during layout)
  (y-coord nil)        ; Y coordinate (set during layout)
  (rank nil)           ; Assigned rank (set during rank assignment)
  (order nil)          ; Order within rank (set during ordering)
  attributes)          ; Additional attributes hash table

(cl-defstruct (dag-draw-edge
               (:constructor dag-draw-edge-create)
               (:copier nil))
  "An edge in a directed graph."
  from-node            ; Source node ID
  to-node              ; Target node ID
  (weight 1)           ; Edge weight for optimization
  (min-length 1)       ; Minimum length constraint
  label                ; Optional edge label
  (spline-points nil)  ; Spline control points (set during spline generation)
  (label-position nil) ; Position for edge label
  attributes)          ; Additional attributes hash table

(cl-defstruct (dag-draw-graph
               (:constructor dag-draw-graph-create)
               (:copier nil))
  "A directed graph."
  (nodes (ht-create 'equal))           ; Hash table: id -> node
  (edges '())                          ; List of edges
  (node-separation dag-draw-default-node-separation)
  (rank-separation dag-draw-default-rank-separation)
  (max-rank nil)                       ; Maximum assigned rank
  (rank-sets nil)                      ; User-specified rank constraints
  attributes)                          ; Graph-level attributes

;;; Public API

;;;###autoload
(defun dag-draw-create-graph (&optional attributes)
  "Create a new empty directed graph with optional ATTRIBUTES."
  (dag-draw-graph-create :attributes (or attributes (ht-create))))

;;;###autoload
(defun dag-draw-add-node (graph node-id &optional label attributes)
  "Add a node with NODE-ID to GRAPH with optional LABEL and ATTRIBUTES.
Auto-sizes the node based on label length and wraps long text for better layout."
  (let* ((node-label (or label (symbol-name node-id)))
         (max-single-line-width 15)  ; Wrap text longer than this
         ;; Wrap text if it's too long
         (text-lines (if (> (length node-label) max-single-line-width)
                         (dag-draw--smart-wrap-text node-label max-single-line-width)
                       (list node-label)))
         ;; Calculate node size based on wrapped text
         (size-info (dag-draw--calculate-wrapped-node-size text-lines))
         (node-width (car size-info))
         (node-height (cdr size-info))
         ;; Create the node with wrapped text as label (joined by newlines)
         (wrapped-label (mapconcat #'identity text-lines "\n"))
         (node (dag-draw-node-create
                :id node-id
                :label wrapped-label
                :x-size node-width
                :y-size node-height
                :attributes (or attributes (ht-create)))))
    (ht-set! (dag-draw-graph-nodes graph) node-id node)
    node))

;;;###autoload
(defun dag-draw-add-edge (graph from-node to-node &optional weight label attributes)
  "Add an edge from FROM-NODE to TO-NODE in GRAPH.
Optional WEIGHT, LABEL, and ATTRIBUTES can be specified."
  (let ((edge (dag-draw-edge-create
               :from-node from-node
               :to-node to-node
               :weight (or weight 1)
               :label label
               :attributes (or attributes (ht-create)))))
    (push edge (dag-draw-graph-edges graph))
    edge))

;;;###autoload
(defun dag-draw-layout-graph (graph)
  "Apply the GKNV layout algorithm to GRAPH.
This performs all four passes: ranking, ordering, positioning, and spline generation."
  (dag-draw-rank-graph graph)
  (dag-draw-order-vertices graph)
  (dag-draw-position-nodes graph)
  (dag-draw-generate-splines graph)
  graph)

;;;###autoload
(defun dag-draw-render-graph (graph &optional format)
  "Render GRAPH in the specified FORMAT (default: `dag-draw-default-output-format').
Returns a string representation of the rendered graph."
  (let ((output-format (or format dag-draw-default-output-format)))
    (cond
     ((eq output-format 'svg)
      (dag-draw-render-svg graph))
     ((eq output-format 'ascii)
      (dag-draw-render-ascii graph))
     ((eq output-format 'dot)
      (dag-draw-render-dot graph))
     (t (error "Unsupported output format: %s" output-format)))))

;;; Implementation placeholders (to be implemented in separate modules)

(declare-function dag-draw-rank-graph "dag-draw-rank")
(declare-function dag-draw-order-vertices "dag-draw-order")
(declare-function dag-draw-position-nodes "dag-draw-position")
(declare-function dag-draw-generate-splines "dag-draw-splines")
(declare-function dag-draw-render-svg "dag-draw-render")
(declare-function dag-draw-render-ascii "dag-draw-render")
(declare-function dag-draw-render-dot "dag-draw-render")

;; Load algorithm modules when needed
(autoload 'dag-draw-rank-graph "dag-draw-rank" "Assign ranks to graph nodes." nil)
(autoload 'dag-draw-order-vertices "dag-draw-order-simple" "Order vertices within ranks." nil)
(autoload 'dag-draw-position-nodes "dag-draw-position" "Assign coordinates to nodes." nil)
(autoload 'dag-draw-generate-splines "dag-draw-splines" "Generate edge splines." nil)
(autoload 'dag-draw-render-svg "dag-draw-render" "Render graph as SVG." nil)
(autoload 'dag-draw-render-ascii "dag-draw-render" "Render graph as ASCII art." nil)
(autoload 'dag-draw-render-dot "dag-draw-render" "Render graph as DOT format." nil)

;;; Text Processing Utilities

(defun dag-draw--smart-wrap-text (text max-width)
  "Wrap TEXT to lines no longer than MAX-WIDTH, breaking at whitespace nearest to middle.
Returns a list of lines."
  (if (<= (length text) max-width)
      (list text)  ; No wrapping needed
    
    ;; Find the best place to break the text
    (let* ((target-pos (/ (length text) 2))  ; Ideal break position (middle)
           (best-pos nil)
           (best-distance most-positive-fixnum))
      
      ;; Find whitespace closest to the middle
      (dotimes (i (length text))
        (when (= (aref text i) ?\s)  ; Found a space
          (let ((distance (abs (- i target-pos))))
            (when (< distance best-distance)
              (setq best-distance distance)
              (setq best-pos i)))))
      
      (if best-pos
          ;; Split at the best whitespace position
          (let ((line1 (substring text 0 best-pos))
                (line2 (substring text (1+ best-pos))))  ; Skip the space
            (cons line1 (dag-draw--smart-wrap-text line2 max-width)))
        ;; No good break point found, force break at max-width
        (list (substring text 0 max-width)
              (substring text max-width))))))

(defun dag-draw--calculate-wrapped-node-size (text-lines)
  "Calculate appropriate node size for wrapped text lines.
Returns (width . height) where width accommodates the longest line
and height accommodates all lines with padding."
  (let* ((max-line-length (apply #'max (mapcar #'length text-lines)))
         (num-lines (length text-lines))
         ;; Base calculations for ASCII rendering
         (grid-scale 2)
         (ascii-box-scale 0.071)
         (min-width 80)
         ;; Calculate width to fit the longest line
         (required-grid-chars (+ max-line-length 4))  ; Text + borders + padding
         (calculated-width (ceiling (/ required-grid-chars
                                      (* grid-scale ascii-box-scale))))
         (node-width (max min-width calculated-width))
         ;; Calculate height for multiple lines
         (line-height 20)  ; Height per line of text
         (base-height 40)  ; Minimum height
         (node-height (max base-height (+ base-height (* (1- num-lines) line-height)))))
    
    (cons node-width node-height)))

;;; Graph utility functions

(defun dag-draw-get-graph-bounds (graph)
  "Get bounding box of the positioned graph.
Returns (min-x min-y max-x max-y)."
  (if (= (ht-size (dag-draw-graph-nodes graph)) 0)
      ;; Empty graph - return default bounds
      (list 0 0 100 100)
    (let ((min-x most-positive-fixnum)
          (min-y most-positive-fixnum)
          (max-x most-negative-fixnum)
          (max-y most-negative-fixnum))
      
      (ht-each (lambda (node-id node)
                 (let* ((x (or (dag-draw-node-x-coord node) 0))
                        (y (or (dag-draw-node-y-coord node) 0))
                        (width (dag-draw-node-x-size node))
                        (height (dag-draw-node-y-size node))
                        (left (- x (/ width 2.0)))
                        (right (+ x (/ width 2.0)))
                        (top (- y (/ height 2.0)))
                        (bottom (+ y (/ height 2.0))))
                   
                   (setq min-x (min min-x left))
                   (setq max-x (max max-x right))
                   (setq min-y (min min-y top))
                   (setq max-y (max max-y bottom))))
               (dag-draw-graph-nodes graph))
      
      (list min-x min-y max-x max-y))))

(provide 'dag-draw)

;;; dag-draw.el ends here