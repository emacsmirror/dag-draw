;;; dag-draw.el --- Draw directed graphs using the Gansner-Koutsofios-North-Vo algorithm -*- lexical-binding: t -*-

;; Copyright (C) 2024

;; Author: Generated by Claude
;; Version: 0.1.0
;; Package-Requires: ((emacs "26.1") (dash "2.19.1") (ht "2.3"))
;; Keywords: graphics, visualization, graphs, diagrams
;; URL: https://github.com/example/dag-draw.el

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <https://www.gnu.org/licenses/>.

;;; Commentary:

;; This package implements the directed graph drawing algorithm described in
;; "A Technique for Drawing Directed Graphs" by Gansner, Koutsofios, North,
;; and Vo (1993).  The algorithm consists of four main passes:
;;
;; 1. Rank assignment using network simplex optimization
;; 2. Vertex ordering within ranks to minimize edge crossings
;; 3. Node coordinate positioning
;; 4. Spline edge drawing using Bézier curves
;;
;; The package provides functions to create, manipulate, and render directed
;; graphs in various formats including SVG and ASCII art.

;;; Code:

(require 'dash)
(require 'ht)

;;; Customization

(defgroup dag-draw nil
  "Draw directed graphs using the GKNV algorithm."
  :group 'graphics
  :prefix "dag-draw-")

(defcustom dag-draw-default-node-separation 20
  "Default minimum horizontal separation between nodes.
Optimized for compact, readable layouts following GKNV algorithm principles."
  :type 'integer
  :group 'dag-draw)

(defcustom dag-draw-default-rank-separation 25
  "Default minimum vertical separation between ranks.
Optimized for compact, readable layouts following GKNV algorithm principles."
  :type 'integer
  :group 'dag-draw)

(defcustom dag-draw-default-output-format 'svg
  "Default output format for rendered graphs."
  :type '(choice (const :tag "SVG" svg)
                 (const :tag "ASCII" ascii)
                 (const :tag "DOT" dot))
  :group 'dag-draw)

;;; Core Data Structures

(cl-defstruct (dag-draw-node
               (:constructor dag-draw-node-create)
               (:copier nil))
  "A node in a directed graph."
  id                    ; Unique identifier
  label                 ; Display label
  (x-size 80)          ; Width of node bounding box
  (y-size 40)          ; Height of node bounding box
  (x-coord nil)        ; X coordinate (set during layout)
  (y-coord nil)        ; Y coordinate (set during layout)
  (rank nil)           ; Assigned rank (set during rank assignment)
  (order nil)          ; Order within rank (set during ordering)
  (virtual-p nil)      ; Whether this is a virtual node (for long edge breaking)
  attributes)          ; Additional attributes hash table

(cl-defstruct (dag-draw-edge
               (:constructor dag-draw-edge-create)
               (:copier nil))
  "An edge in a directed graph."
  from-node            ; Source node ID
  to-node              ; Target node ID
  (weight 1)           ; Edge weight for optimization
  (min-length 1)       ; Minimum length constraint
  label                ; Optional edge label
  (spline-points nil)  ; Spline control points (set during spline generation)
  (label-position nil) ; Position for edge label
  attributes)          ; Additional attributes hash table

(cl-defstruct (dag-draw-graph
               (:constructor dag-draw-graph-create)
               (:copier nil))
  "A directed graph."
  (nodes (ht-create 'equal))           ; Hash table: id -> node
  (edges '())                          ; List of edges
  (node-separation dag-draw-default-node-separation)
  (rank-separation dag-draw-default-rank-separation)
  (max-rank nil)                       ; Maximum assigned rank
  (rank-sets nil)                      ; User-specified rank constraints
  (adjusted-positions nil)             ; Hash table: id -> (x y width height) adjusted coordinates
  attributes)                          ; Graph-level attributes

;;; Public API

;;;###autoload
(defun dag-draw-create-graph (&optional attributes)
  "Create a new empty directed graph with optional ATTRIBUTES."
  (dag-draw-graph-create :attributes (or attributes (ht-create))))

;;;###autoload
(defun dag-draw-add-node (graph node-id &optional label attributes)
  "Add a node with NODE-ID to GRAPH with optional LABEL and ATTRIBUTES.
Auto-sizes the node based on label length using 2 rows × 20 characters constraint."
  (let* ((node-label (or label (symbol-name node-id)))
         ;; Use the constrained text formatting (2 rows × 20 chars max)
         (text-lines (dag-draw--format-node-text-with-constraints node-label))
         ;; Calculate variable node size based on actual formatted text
         (size-info (dag-draw--calculate-constrained-node-size text-lines))
         (node-width (car size-info))
         (node-height (cdr size-info))
         ;; Create the node with formatted text as label (joined by newlines)
         (formatted-label (mapconcat #'identity text-lines "\n"))
         (node (dag-draw-node-create
                :id node-id
                :label formatted-label
                :x-size node-width
                :y-size node-height
                :attributes (or attributes (ht-create)))))
    (ht-set! (dag-draw-graph-nodes graph) node-id node)
    node))

;;;###autoload
(defun dag-draw-add-edge (graph from-node to-node &optional weight label attributes)
  "Add an edge from FROM-NODE to TO-NODE in GRAPH.
Optional WEIGHT, LABEL, and ATTRIBUTES can be specified."
  (let ((edge (dag-draw-edge-create
               :from-node from-node
               :to-node to-node
               :weight (or weight 1)
               :label label
               :attributes (or attributes (ht-create)))))
    (push edge (dag-draw-graph-edges graph))
    edge))

;;;###autoload
(defun dag-draw-layout-graph (graph)
  "Apply the GKNV layout algorithm to GRAPH.
This performs all four passes: ranking, ordering, positioning, and spline generation."
  (dag-draw-rank-graph graph)
  (dag-draw-order-vertices graph)
  (dag-draw-position-nodes graph)
  (dag-draw-generate-splines graph)
  graph)

;;;###autoload
(defun dag-draw-render-graph (graph &optional format)
  "Render GRAPH in the specified FORMAT (default: `dag-draw-default-output-format').
Returns a string representation of the rendered graph."
  (let ((output-format (or format dag-draw-default-output-format)))
    (cond
     ((eq output-format 'svg)
      (dag-draw-render-svg graph))
     ((eq output-format 'ascii)
      (dag-draw-render-ascii graph))
     ((eq output-format 'dot)
      (dag-draw-render-dot graph))
     (t (error "Unsupported output format: %s" output-format)))))

;;; Implementation placeholders (to be implemented in separate modules)

(declare-function dag-draw-rank-graph "dag-draw-rank")
(declare-function dag-draw-order-vertices "dag-draw-order")
(declare-function dag-draw-position-nodes "dag-draw-position")
(declare-function dag-draw-generate-splines "dag-draw-splines")
(declare-function dag-draw-render-svg "dag-draw-render")
(declare-function dag-draw-render-ascii "dag-draw-render")
(declare-function dag-draw-render-dot "dag-draw-render")

;; Load algorithm modules when needed
(autoload 'dag-draw-rank-graph "dag-draw-rank" "Assign ranks to graph nodes." nil)
(autoload 'dag-draw-order-vertices "dag-draw-order-simple" "Order vertices within ranks." nil)
(autoload 'dag-draw-position-nodes "dag-draw-position" "Assign coordinates to nodes." nil)
(autoload 'dag-draw-generate-splines "dag-draw-splines" "Generate edge splines." nil)
(autoload 'dag-draw-render-svg "dag-draw-render" "Render graph as SVG." nil)
(autoload 'dag-draw-render-ascii "dag-draw-render" "Render graph as ASCII art." nil)
(autoload 'dag-draw-render-dot "dag-draw-render" "Render graph as DOT format." nil)

;;; Text Processing Utilities

(defun dag-draw--format-node-text-with-constraints (text)
  "Format TEXT for constrained node size (max 2 rows, 20 chars each).
Returns a list of strings representing the formatted rows.
This implements the user requirement for variable node sizes with constraints."
  (if (<= (length text) 20)
      (list text)
    ;; Check if text has no spaces (single long word)
    (if (not (string-match " " text))
        ;; Handle single long word - truncate with ellipsis
        (list (concat (substring text 0 17) "..."))
      ;; Word wrapping for text longer than 20 chars
      (let ((words (split-string text " "))
            (line1 "")
            (line2 ""))
        ;; Fill first line up to 20 chars
        (while (and words (<= (+ (length line1) (length (car words)) (if (string-empty-p line1) 0 1)) 20))
          (setq line1 (if (string-empty-p line1)
                          (car words)
                        (concat line1 " " (car words))))
          (setq words (cdr words)))
        ;; Fill second line up to 20 chars
        (when words
          (let ((remaining-text (mapconcat 'identity words " ")))
            (if (<= (length remaining-text) 20)
                ;; All remaining text fits in second line
                (setq line2 remaining-text)
              ;; Need to truncate with ellipsis
              (while (and words (<= (+ (length line2) (length (car words)) (if (string-empty-p line2) 0 1)) 17))
                (setq line2 (if (string-empty-p line2)
                                (car words)
                              (concat line2 " " (car words))))
                (setq words (cdr words)))
              (setq line2 (concat line2 "...")))))
        (if (string-empty-p line2)
            (list line1)
          (list line1 line2))))))

(defun dag-draw--calculate-constrained-node-size (text-lines)
  "Calculate appropriate variable node size for constrained text lines.
Returns (width . height) where dimensions fit the actual text content.
This enables GKNV variable node sizing while respecting user constraints."
  (let* ((max-line-length (apply #'max (mapcar #'length text-lines)))
         (num-lines (length text-lines))
         ;; SCALING FIX: Use global parameter to eliminate double scaling
         (grid-scale 2)
         ;; MATHEMATICAL UNIFICATION FIX: Use unified coordinate scale
         (ascii-box-scale (if (boundp 'dag-draw-ascii-coordinate-scale) 
                             dag-draw-ascii-coordinate-scale 
                             0.15))  ; Use unified scale for mathematical consistency
         (min-width 147)  ; FIXED: Ensure 20+ character interior space after grid conversion (147*0.15=22, 22-2=20 chars)
         ;; Calculate width to fit the longest line (variable sizing)
         (required-grid-chars (+ max-line-length 4))  ; Text + borders + padding
         (calculated-width (ceiling (/ required-grid-chars
                                      (* grid-scale ascii-box-scale))))
         (node-width (max min-width calculated-width))
         ;; Calculate height based on actual number of lines (minimal sizing)
         (base-height-per-line 6)
         (border-height 8)
         (calculated-height (+ (* num-lines base-height-per-line) border-height))
         (node-height calculated-height))
    
    (cons node-width node-height)))

(defun dag-draw--smart-wrap-text (text max-width)
  "Wrap TEXT to lines no longer than MAX-WIDTH, breaking at whitespace nearest to middle.
Returns a list of lines."
  (if (<= (length text) max-width)
      (list text)  ; No wrapping needed
    
    ;; Find the best place to break the text
    (let* ((target-pos (/ (length text) 2))  ; Ideal break position (middle)
           (best-pos nil)
           (best-distance most-positive-fixnum))
      
      ;; Find whitespace closest to the middle
      (dotimes (i (length text))
        (when (= (aref text i) ?\s)  ; Found a space
          (let ((distance (abs (- i target-pos))))
            (when (< distance best-distance)
              (setq best-distance distance)
              (setq best-pos i)))))
      
      (if best-pos
          ;; Split at the best whitespace position
          (let ((line1 (substring text 0 best-pos))
                (line2 (substring text (1+ best-pos))))  ; Skip the space
            (cons line1 (dag-draw--smart-wrap-text line2 max-width)))
        ;; No good break point found, force break at max-width
        (list (substring text 0 max-width)
              (substring text max-width))))))

(defun dag-draw--calculate-wrapped-node-size (text-lines)
  "Calculate appropriate node size for wrapped text lines.
Returns (width . height) where width accommodates the longest line
and height accommodates all lines with padding.
GKNV-compatible: Uses fixed height to maintain algorithm assumptions."
  (let* ((max-line-length (apply #'max (mapcar #'length text-lines)))
         (num-lines (length text-lines))
         ;; MATHEMATICAL UNIFICATION FIX: Use unified coordinate scale
         (grid-scale 2)
         (ascii-box-scale (if (boundp 'dag-draw-ascii-coordinate-scale) 
                             dag-draw-ascii-coordinate-scale 
                             0.15))  ; Use unified scale for mathematical consistency
         (min-width 147)  ; FIXED: Ensure 20+ character interior space after grid conversion (147*0.15=22, 22-2=20 chars)
         ;; Calculate width to fit the longest line
         (required-grid-chars (+ max-line-length 4))  ; Text + borders + padding
         (calculated-width (ceiling (/ required-grid-chars
                                      (* grid-scale ascii-box-scale))))
         (node-width (max min-width calculated-width))
         ;; GKNV-compatible: Use fixed height to maintain algorithm assumptions
         ;; The original GKNV algorithm expects consistent node dimensions
         (base-height 14)  ; Minimal fixed height for optimal visual density
         (node-height base-height))  ; Always use base height for layout consistency
    
    (cons node-width node-height)))

;;; Graph utility functions

(defun dag-draw-get-graph-bounds (graph)
  "Get bounding box of the positioned graph.
Returns (min-x min-y max-x max-y)."
  (if (= (ht-size (dag-draw-graph-nodes graph)) 0)
      ;; Empty graph - return default bounds
      (list 0 0 100 100)
    (let ((min-x most-positive-fixnum)
          (min-y most-positive-fixnum)
          (max-x most-negative-fixnum)
          (max-y most-negative-fixnum))
      
      (ht-each (lambda (node-id node)
                 (let* ((x (or (dag-draw-node-x-coord node) 0))
                        (y (or (dag-draw-node-y-coord node) 0))
                        (width (dag-draw-node-x-size node))
                        (height (dag-draw-node-y-size node))
                        (left (- x (/ width 2.0)))
                        (right (+ x (/ width 2.0)))
                        (top (- y (/ height 2.0)))
                        (bottom (+ y (/ height 2.0))))
                   
                   (setq min-x (min min-x left))
                   (setq max-x (max max-x right))
                   (setq min-y (min min-y top))
                   (setq max-y (max max-y bottom))))
               (dag-draw-graph-nodes graph))
      
      (list min-x min-y max-x max-y))))

(provide 'dag-draw)

;;; dag-draw.el ends here