;;; dag-draw.el --- Draw directed graphs using the Gansner-Koutsofios-North-Vo algorithm -*- lexical-binding: t -*-

;; Copyright (C) 2024

;; Author: Generated by Claude
;; Version: 0.1.0
;; Package-Requires: ((emacs "26.1") (dash "2.19.1") (ht "2.3"))
;; Keywords: graphics, visualization, graphs, diagrams
;; URL: https://github.com/example/dag-draw.el

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <https://www.gnu.org/licenses/>.

;;; Commentary:

;; This package implements the directed graph drawing algorithm described in
;; "A Technique for Drawing Directed Graphs" by Gansner, Koutsofios, North,
;; and Vo (1993).  The algorithm consists of four main passes:
;;
;; 1. Rank assignment using network simplex optimization
;; 2. Vertex ordering within ranks to minimize edge crossings
;; 3. Node coordinate positioning
;; 4. Spline edge drawing using Bézier curves
;;
;; The package provides functions to create, manipulate, and render directed
;; graphs in various formats including SVG and ASCII art.

;;; Code:

(require 'dash)
(require 'ht)

;;; Customization

(defgroup dag-draw nil
  "Draw directed graphs using the GKNV algorithm."
  :group 'graphics
  :prefix "dag-draw-")

(defcustom dag-draw-default-node-separation 20
  "Default minimum horizontal separation between nodes.
Optimized for compact, readable layouts following GKNV algorithm principles."
  :type 'integer
  :group 'dag-draw)

(defcustom dag-draw-default-rank-separation 25
  "Default minimum vertical separation between ranks.
Optimized for compact, readable layouts following GKNV algorithm principles."
  :type 'integer
  :group 'dag-draw)

(defcustom dag-draw-ascii-coordinate-scale 0.15
  "Scale factor for converting GKNV algorithm coordinates to ASCII grid positions.

ASCII CHARACTER CONSTRAINTS:
- GKNV paper suggests '72 units per inch' for high-resolution graphics
- ASCII terminals have ~5 characters per inch in typical monospace fonts
- Scale factor needed: 72 ÷ 5 = ~14.4x compression from GKNV to ASCII
- Our 0.15 scale provides balanced compression avoiding coordinate collapse

VISUAL RESULT: Prevents negative coordinates while maintaining readable layout."
  :type 'float
  :group 'dag-draw)

(defcustom dag-draw-default-output-format 'svg
  "Default output format for rendered graphs."
  :type '(choice (const :tag "SVG" svg)
                 (const :tag "ASCII" ascii)
                 (const :tag "DOT" dot))
  :group 'dag-draw)

;;; Core Data Structures

(cl-defstruct (dag-draw-node
               (:constructor dag-draw-node-create)
               (:copier nil))
  "A node in a directed graph."
  id                    ; Unique identifier
  label                 ; Display label
  (x-size 80)          ; Width of node bounding box
  (y-size 40)          ; Height of node bounding box
  (x-coord nil)        ; X coordinate (set during layout)
  (y-coord nil)        ; Y coordinate (set during layout)
  (rank nil)           ; Assigned rank (set during rank assignment)
  (order nil)          ; Order within rank (set during ordering)
  (virtual-p nil)      ; Whether this is a virtual node (for long edge breaking)
  attributes)          ; Additional attributes hash table

(cl-defstruct (dag-draw-edge
               (:constructor dag-draw-edge-create)
               (:copier nil))
  "An edge in a directed graph."
  from-node            ; Source node ID
  to-node              ; Target node ID
  (weight 1)           ; Edge weight for optimization
  (min-length 1)       ; Minimum length constraint
  label                ; Optional edge label
  (spline-points nil)  ; Spline control points (set during spline generation)
  (label-position nil) ; Position for edge label
  attributes)          ; Additional attributes hash table

(cl-defstruct (dag-draw-graph
               (:constructor dag-draw-graph-create)
               (:copier nil))
  "A directed graph."
  (nodes (ht-create 'equal))           ; Hash table: id -> node
  (edges '())                          ; List of edges
  (node-separation dag-draw-default-node-separation)
  (rank-separation dag-draw-default-rank-separation)
  (max-rank nil)                       ; Maximum assigned rank
  (rank-sets nil)                      ; User-specified rank constraints
  (adjusted-positions nil)             ; Hash table: id -> (x y width height) adjusted coordinates
  attributes)                          ; Graph-level attributes

;;; Public API

;;;###autoload
(defun dag-draw-create-graph (&optional attributes)
  "Create a new empty directed graph with optional ATTRIBUTES."
  (dag-draw-graph-create :attributes (or attributes (ht-create))))

;;;###autoload
(defun dag-draw-add-node (graph node-id &optional label attributes)
  "Add a node with NODE-ID to GRAPH with optional LABEL and ATTRIBUTES.
Auto-sizes the node based on label length using 2 rows × 20 characters constraint."
  (let* ((node-label (or label (symbol-name node-id)))
         ;; Use the constrained text formatting (2 rows × 20 chars max)
         (text-lines (dag-draw--format-node-text-with-constraints node-label))
         ;; Calculate variable node size based on actual formatted text
         (size-info (dag-draw--calculate-constrained-node-size text-lines))
         (node-width (car size-info))
         (node-height (cdr size-info))
         ;; Create the node with formatted text as label (joined by newlines)
         (formatted-label (mapconcat #'identity text-lines "\n"))
         (node (dag-draw-node-create
                :id node-id
                :label formatted-label
                :x-size node-width
                :y-size node-height
                :attributes (or attributes (ht-create)))))
    (ht-set! (dag-draw-graph-nodes graph) node-id node)
    node))

;;;###autoload
(defun dag-draw-add-edge (graph from-node to-node &optional weight label attributes)
  "Add an edge from FROM-NODE to TO-NODE in GRAPH.
Optional WEIGHT, LABEL, and ATTRIBUTES can be specified."
  (let* ((attrs (or attributes (ht-create)))
         (min-length (or (and attrs (ht-get attrs 'min-length)) 1))
         (edge (dag-draw-edge-create
                :from-node from-node
                :to-node to-node
                :weight (or weight 1)
                :min-length min-length
                :label label
                :attributes attrs)))
    (push edge (dag-draw-graph-edges graph))
    edge))

;;;###autoload
(defun dag-draw-layout-graph (graph)
  "Apply the GKNV layout algorithm to GRAPH with ASCII resolution preprocessing.
This performs the four GKNV passes with ASCII resolution after ranking:
ranking, ASCII resolution adjustment, ordering, positioning, and spline generation."
  ;; GKNV Pass 1: Rank assignment
  (dag-draw-rank-graph graph)
  
  ;; ASCII resolution preprocessing (moved after ranking for dynamic analysis)
  (dag-draw--ensure-ascii-resolution graph)
  
  ;; GKNV Passes 2-4: ordering, positioning, and spline generation
  (dag-draw-order-vertices graph)
  (dag-draw-position-nodes graph)
  (dag-draw-generate-splines graph)
  graph)

;;; ASCII Resolution Preprocessing

(defun dag-draw--estimate-ascii-scale (graph)
  "Estimate the scale factor that will be used for ASCII conversion.
Returns the actual scale factor used for world-coordinates → ASCII-grid conversion."
  ;; Currently uses a fixed scale factor, but this function allows for future
  ;; dynamic scaling based on graph size and complexity
  dag-draw-ascii-coordinate-scale)


(defun dag-draw--calculate-min-ascii-routing-space (&optional graph)
  "Calculate minimum ASCII characters needed for clean edge routing.
If GRAPH is provided, uses dynamic analysis of edge patterns for optimal spacing.
Otherwise uses safe defaults for edge routing."
  (let* ((min-vertical (if graph
                           ;; Dynamic calculation based on graph structure
                           (progn
                             (require 'dag-draw-quality)
                             (let ((dynamic-spacing (dag-draw--calculate-max-required-rank-separation graph)))
                               (message "DYNAMIC-SPACING: Calculated %d rows for graph (nodes: %d, edges: %d)" 
                                        dynamic-spacing (dag-draw-node-count graph) (dag-draw-edge-count graph))
                               (dag-draw--debug-spacing-calculation graph)
                               dynamic-spacing))
                         ;; Safe default for edge routing  
                         2))
         ;; Calculate minimum horizontal separation based on actual node sizes
         (min-horizontal (if graph
                             ;; Find the maximum ASCII node width in the graph and add buffer
                             (let ((scale (dag-draw--estimate-ascii-scale graph))
                                   (max-ascii-width 0))
                               (ht-each (lambda (node-id node)
                                          (let ((ascii-width (dag-draw--world-to-grid-size 
                                                             (dag-draw-node-x-size node) scale)))
                                            (setq max-ascii-width (max max-ascii-width ascii-width))))
                                        (dag-draw-graph-nodes graph))
                               ;; Use max node width plus minimum buffer for routing
                               (+ max-ascii-width 6))
                           ;; Safe default if no graph provided
                           12)))
    (list 
     :min-horizontal min-horizontal  ; Dynamic horizontal spacing based on node sizes
     :min-vertical min-vertical      ; Dynamic rows between ranks based on edge analysis
     :port-offset 2)))               ; Space needed for port positioning variety

(defun dag-draw--adjust-separations-for-ascii (graph)
  "Adjust nodesep/ranksep to ensure sufficient ASCII resolution.
Called BEFORE GKNV passes to ensure clean edge routing space."
  (let* ((scale (dag-draw--estimate-ascii-scale graph))
         (requirements (dag-draw--calculate-min-ascii-routing-space graph))
         (min-world-nodesep (/ (float (plist-get requirements :min-horizontal)) scale))
         (min-world-ranksep (/ (float (plist-get requirements :min-vertical)) scale)))
    
    ;; Increase separations if needed for ASCII resolution
    (when (< (dag-draw-graph-node-separation graph) min-world-nodesep)
      (message "ASCII-RESOLUTION: Increasing nodesep from %.1f to %.1f for scale %.3f" 
               (dag-draw-graph-node-separation graph) min-world-nodesep scale)
      (setf (dag-draw-graph-node-separation graph) min-world-nodesep))
    
    (when (< (dag-draw-graph-rank-separation graph) min-world-ranksep)
      (message "ASCII-RESOLUTION: Increasing ranksep from %.1f to %.1f for scale %.3f"
               (dag-draw-graph-rank-separation graph) min-world-ranksep scale)
      (setf (dag-draw-graph-rank-separation graph) min-world-ranksep))))

(defun dag-draw--ensure-ascii-resolution (graph)
  "Ensure ASCII grid will have sufficient resolution for edge routing.
Must be called BEFORE dag-draw-layout-graph to adjust parameters."
  (dag-draw--adjust-separations-for-ascii graph)
  (message "ASCII-RESOLUTION: Graph prepared for scale %.3f" 
           (dag-draw--estimate-ascii-scale graph)))

;;;###autoload
(defun dag-draw-render-graph (graph &optional format)
  "Render GRAPH in the specified FORMAT (default: `dag-draw-default-output-format').
Returns a string representation of the rendered graph."
  (let ((output-format (or format dag-draw-default-output-format)))
    (cond
     ((eq output-format 'svg)
      (dag-draw-render-svg graph))
     ((eq output-format 'ascii)
      (dag-draw-render-ascii graph))
     ((eq output-format 'dot)
      (dag-draw-render-dot graph))
     (t (error "Unsupported output format: %s" output-format)))))

;;; Implementation placeholders (to be implemented in separate modules)

(declare-function dag-draw-rank-graph "dag-draw-pass1-ranking")
(declare-function dag-draw-order-vertices "dag-draw-pass2-ordering")
(declare-function dag-draw-position-nodes "dag-draw-pass3-positioning")
(declare-function dag-draw-generate-splines "dag-draw-pass4-splines")
(declare-function dag-draw-render-svg "dag-draw-render")
(declare-function dag-draw-render-ascii "dag-draw-render")
(declare-function dag-draw-render-dot "dag-draw-render")

;; Load algorithm modules when needed
(autoload 'dag-draw-rank-graph "dag-draw-pass1-ranking" "Assign ranks to graph nodes." nil)
(autoload 'dag-draw-order-vertices "dag-draw-pass2-ordering" "Order vertices within ranks." nil)
(autoload 'dag-draw-position-nodes "dag-draw-pass3-positioning" "Assign coordinates to nodes." nil)
(autoload 'dag-draw-generate-splines "dag-draw-pass4-splines" "Generate edge splines." nil)
(autoload 'dag-draw-render-svg "dag-draw-render" "Render graph as SVG." nil)
(autoload 'dag-draw-render-ascii "dag-draw-render" "Render graph as ASCII art." nil)
(autoload 'dag-draw-render-dot "dag-draw-render" "Render graph as DOT format." nil)

;;; Text Processing Utilities

(defun dag-draw--format-node-text-with-constraints (text)
  "Format TEXT for node display with expanded constraints.
Returns a list of strings representing the formatted rows.
Supports longer text labels while maintaining readable formatting."
  (let ((max-chars-per-line 25))  ; Increased from 20 to 25 characters per line
    (if (<= (length text) max-chars-per-line)
        (list text)
      ;; Check if text has no spaces (single long word)
      (if (not (string-match " " text))
          ;; Handle single long word - truncate with ellipsis only if extremely long
          (if (> (length text) 30)
              (list (concat (substring text 0 27) "..."))
            (list text))  ; Allow single words up to 30 characters
        ;; Word wrapping for text longer than max-chars-per-line
        (let ((words (split-string text " "))
              (line1 "")
              (line2 ""))
          ;; Fill first line up to max-chars-per-line
          (while (and words (<= (+ (length line1) (length (car words)) (if (string-empty-p line1) 0 1)) max-chars-per-line))
            (setq line1 (if (string-empty-p line1)
                            (car words)
                          (concat line1 " " (car words))))
            (setq words (cdr words)))
          ;; Fill second line up to max-chars-per-line
          (when words
            (let ((remaining-text (mapconcat 'identity words " ")))
              (if (<= (length remaining-text) max-chars-per-line)
                  ;; All remaining text fits in second line
                  (setq line2 remaining-text)
                ;; Need to truncate with ellipsis only if extremely long
                (while (and words (<= (+ (length line2) (length (car words)) (if (string-empty-p line2) 0 1)) (- max-chars-per-line 3)))
                  (setq line2 (if (string-empty-p line2)
                                  (car words)
                                (concat line2 " " (car words))))
                  (setq words (cdr words)))
                (when words  ; Only add ellipsis if there are still remaining words
                  (setq line2 (concat line2 "..."))))))
          (if (string-empty-p line2)
              (list line1)
            (list line1 line2)))))))

(defun dag-draw--calculate-constrained-node-size (text-lines)
  "Calculate appropriate variable node size for constrained text lines.
ASCII-FIRST APPROACH: Measures actual ASCII grid requirements, then converts to world coordinates.
Returns (width . height) where dimensions fit the actual text content per GKNV Section 1.2."
  (let* ((max-line-length (apply #'max (mapcar #'length text-lines)))
         (num-lines (length text-lines))
         ;; ASCII-FIRST CALCULATION: Direct measurement of actual requirements
         (ascii-width-needed (+ max-line-length 4))    ; Text + left/right borders + padding
         (ascii-height-needed (+ num-lines 2))         ; Text lines + top/bottom borders
         ;; MATHEMATICAL UNIFICATION: Use unified coordinate scale for conversion
         (ascii-box-scale (if (boundp 'dag-draw-ascii-coordinate-scale)
                              dag-draw-ascii-coordinate-scale
                            0.15))  ; Use unified scale for mathematical consistency
         ;; Convert ASCII requirements to world coordinates
         (calculated-width (/ ascii-width-needed ascii-box-scale))
         (calculated-height (/ ascii-height-needed ascii-box-scale))
         ;; GKNV-COMPLIANT SIZE CONSTRAINTS: Variable sizing with practical limits
         (min-width 60)     ; Minimum for very short text (prevents unusably tiny nodes)
         (max-width 170)    ; Maximum proven to work well (prevents layout issues)
         (node-width (max min-width (min max-width calculated-width)))
         (node-height (max 14 calculated-height)))  ; Minimum reasonable height

    (cons node-width node-height)))

(defun dag-draw--smart-wrap-text (text max-width)
  "Wrap TEXT to lines no longer than MAX-WIDTH, breaking at whitespace nearest to middle.
Returns a list of lines."
  (if (<= (length text) max-width)
      (list text)  ; No wrapping needed

    ;; Find the best place to break the text
    (let* ((target-pos (/ (length text) 2))  ; Ideal break position (middle)
           (best-pos nil)
           (best-distance most-positive-fixnum))

      ;; Find whitespace closest to the middle
      (dotimes (i (length text))
        (when (= (aref text i) ?\s)  ; Found a space
          (let ((distance (abs (- i target-pos))))
            (when (< distance best-distance)
              (setq best-distance distance)
              (setq best-pos i)))))

      (if best-pos
          ;; Split at the best whitespace position
          (let ((line1 (substring text 0 best-pos))
                (line2 (substring text (1+ best-pos))))  ; Skip the space
            (cons line1 (dag-draw--smart-wrap-text line2 max-width)))
        ;; No good break point found, force break at max-width
        (list (substring text 0 max-width)
              (substring text max-width))))))


;;; Graph utility functions

(defun dag-draw-get-graph-bounds (graph)
  "Get bounding box of the positioned graph.
Returns (min-x min-y max-x max-y)."
  (if (= (ht-size (dag-draw-graph-nodes graph)) 0)
      ;; Empty graph - return default bounds
      (list 0 0 100 100)
    (let ((min-x most-positive-fixnum)
          (min-y most-positive-fixnum)
          (max-x most-negative-fixnum)
          (max-y most-negative-fixnum))

      (ht-each (lambda (node-id node)
                 (let* ((x (or (dag-draw-node-x-coord node) 0))
                        (y (or (dag-draw-node-y-coord node) 0))
                        (width (dag-draw-node-x-size node))
                        (height (dag-draw-node-y-size node))
                        (left (- x (/ width 2.0)))
                        (right (+ x (/ width 2.0)))
                        (top (- y (/ height 2.0)))
                        (bottom (+ y (/ height 2.0))))


                   (setq min-x (min min-x left))
                   (setq max-x (max max-x right))
                   (setq min-y (min min-y top))
                   (setq max-y (max max-y bottom))))
               (dag-draw-graph-nodes graph))

      (list min-x min-y max-x max-y))))

;;; GKNV Mathematical Notation Aliases
;; Section references from "A Technique for Drawing Directed Graphs"

(defalias 'dag-draw-edge-δ 'dag-draw-edge-min-length
  "GKNV δ(e) - minimum edge length constraint (Section 2, line 356).
Alias for dag-draw-edge-min-length using proper Greek mathematical notation.")

(defalias 'dag-draw-edge-ω 'dag-draw-edge-weight  
  "GKNV ω(e) - edge weight for optimization (Section 1.2, line 83).
Alias for dag-draw-edge-weight using proper Greek mathematical notation.")

(defalias 'dag-draw-node-λ 'dag-draw-node-rank
  "GKNV λ(v) - rank assignment function (Section 2, line 352).
Alias for dag-draw-node-rank using proper Greek mathematical notation.")

;; Declare ρ function for separation calculations
(declare-function dag-draw--calculate-separation "dag-draw-pass3-positioning")
(defalias 'dag-draw-ρ 'dag-draw--calculate-separation
  "GKNV ρ(u,v) - minimum separation function between adjacent nodes.
ρ(u,v) = (xsize(u) + xsize(v))/2 + nodesep(G) per Section 4.")

(provide 'dag-draw)

;;; dag-draw.el ends here
