#+TITLE: Dag Draw User Manual
:PREAMBLE:
#+AUTHOR: Generated by Claude
#+EMAIL: example@example.com
#+DATE: 2024-{{{year}}}
#+LANGUAGE: en

#+TEXINFO_DIR_CATEGORY: Emacs
#+TEXINFO_DIR_TITLE: Dag Draw: (dag-draw)
#+TEXINFO_DIR_DESC: Draw directed acyclic graphs that don't suck
#+TEXINFO_FILENAME: ../dag-draw.info
#+SUBTITLE: for version 0.1.0
#+TEXINFO_DEFFN: t
#+OPTIONS: H:4 num:3 toc:2
#+PROPERTY: header-args :eval never
#+MACRO: year (eval (format-time-string "%Y"))

Dag Draw is an Emacs Lisp library for drawing directed acyclic graphs (DAGs) using the industry-standard GKNV algorithm from Graphviz.

#+TEXINFO: @noindent
This manual is for Dag Draw version 0.1.0

:END:
* Copying
:PROPERTIES:
:copying:  t
:END:
#+TEXINFO: noindent
SPDX-License-Identifier: GPL-3.0

Copyright (C) 2023-{{{year}}}

You can redistribute this document and/or modify it under the terms
of the GNU General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any
later version.

This document is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

* Introduction
:PROPERTIES:
:DESCRIPTION: What is dag-draw and why should you care?
:END:

** What is dag-draw?

Ever tried to draw a flowchart? You spend hours moving boxes around, trying to untangle crossing lines, and the result still looks like spaghetti.

*dag-draw.el* solves this problem. You focus on the *structure* (what connects to what), and it handles the *layout* (where everything goes).

Instead of manually positioning boxes and arrows, you write:

#+begin_src emacs-lisp
;; You write this:
(setq my-graph (dag-draw-create-graph))
(dag-draw-add-node my-graph 'design "Design")
(dag-draw-add-node my-graph 'build "Build")
(dag-draw-add-node my-graph 'test "Test")
(dag-draw-add-edge my-graph 'design 'build)
(dag-draw-add-edge my-graph 'design 'test)
(dag-draw-add-edge my-graph 'build 'test)
(dag-draw-layout-graph my-graph)
(dag-draw-render-graph my-graph 'ascii)
#+end_src

And it produces:

#+begin_example
┌──────┐
│Design│
└───┬──┘
    │
    ├────────────────┐
    │                │
    ▼                ▼
┌───────┐        ┌──────┐
│Build  │───────▶│Test  │
└───────┘        └──────┘
#+end_example

*No manual positioning. No tangled arrows. Just clean, hierarchical layouts.*

** Why use dag-draw?

*For end users:*
- *Save time*: No more manual layout adjustments
- *Professional results*: Uses the same algorithm as Graphviz
- *Multiple formats*: Output to ASCII (terminal/docs) or SVG (web/presentations)
- *Pure Elisp*: No external dependencies, works anywhere Emacs runs

*Common use cases:*
- Project dependency visualization (Task A must finish before B and C)
- Course prerequisite charts (You need Calc I before Calc II)
- File dependency graphs (main.c includes utils.h)
- Workflow diagrams (Design → Build → Test → Deploy)
- Any hierarchical relationship that forms a DAG

** What's a DAG?

A *Directed Acyclic Graph* is:
- *Directed*: Arrows point in specific directions (A → B means "A comes before B")
- *Acyclic*: No loops (you can't follow arrows and end up back where you started)
- *Graph*: Nodes (boxes) connected by edges (arrows)

Think of a family tree, or a course prerequisite chart. These are DAGs because:
- Relationships have direction (parent → child, prerequisite → course)
- No cycles exist (you can't be your own ancestor, a course can't require itself)

Valid DAG:
#+begin_example
A → B → C
#+end_example

Invalid (has a cycle):
#+begin_example
A → B → C → A  (cycle!)
#+end_example

** How does it work?

dag-draw implements the *GKNV algorithm* from a seminal 1993 paper:

#+begin_quote
Gansner, E. R., Koutsofios, E., North, S. C., & Vo, K. P. (1993).
"A Technique for Drawing Directed Graphs."
IEEE Transactions on Software Engineering, 19(3), 214-230.
#+end_quote

This is the same algorithm used by *Graphviz*, the industry standard for graph layout. It has been cited thousands of times and is optimal for hierarchical graphs.

The algorithm runs in four automatic passes:
1. *Ranking*: Assigns vertical levels (what goes on top, middle, bottom)
2. *Ordering*: Arranges nodes horizontally to minimize crossing arrows
3. *Positioning*: Calculates exact X,Y coordinates
4. *Splines*: Draws smooth curves for edges

You don't need to understand the algorithm to use dag-draw. Just call ~dag-draw-layout-graph~ and it handles everything.

* Getting Started
:PROPERTIES:
:DESCRIPTION: Your first graph in 30 seconds
:CUSTOM_ID: getting-started
:END:

This section will teach you to create and render your first graph. By the end, you'll have a working example you can modify.

** Installation
:PROPERTIES:
:DESCRIPTION: Get dag-draw into your Emacs
:END:

*** Dependencies

dag-draw requires:
- Emacs 26.1 or higher
- ~dash~ library (list manipulation)
- ~ht~ library (hash tables)

*** From Source

Clone the repository and add to your load path:

#+begin_src bash
git clone https://github.com/example/dag-draw.el.git
#+end_src

Add to your Emacs configuration:

#+begin_src emacs-lisp
(add-to-list 'load-path "~/path/to/dag-draw.el")
(require 'dag-draw)
#+end_src

*** Using package.el

When released on MELPA:

#+begin_src emacs-lisp
M-x package-install RET dag-draw RET
#+end_src

** Your First Graph (The Black Triangle)
:PROPERTIES:
:DESCRIPTION: A working example in 30 seconds
:END:

Let's create a simple three-step workflow. Type this into your ~*scratch*~ buffer and evaluate with ~C-x C-e~:

#+begin_src emacs-lisp
(require 'dag-draw)

;; Step 1: Create a graph
(setq my-graph (dag-draw-create-graph))

;; Step 2: Add nodes
(dag-draw-add-node my-graph 'start "Start Here")
(dag-draw-add-node my-graph 'middle "Do Work")
(dag-draw-add-node my-graph 'done "Finish")

;; Step 3: Connect them with edges
(dag-draw-add-edge my-graph 'start 'middle)
(dag-draw-add-edge my-graph 'middle 'done)

;; Step 4: Layout and render
(dag-draw-layout-graph my-graph)
(dag-draw-render-graph my-graph 'ascii)
#+end_src

You should see:

#+begin_example
┌────────────┐
│Start Here  │
└──────┬─────┘
       │
       ▼
┌────────────┐
│Do Work     │
└──────┬─────┘
       │
       ▼
┌────────────┐
│Finish      │
└────────────┘
#+end_example

*Congratulations!* You just created your first automatically-laid-out graph.

** Understanding What Just Happened

Let's break down each step:

*** Step 1: Create a Graph

#+begin_src emacs-lisp
(setq my-graph (dag-draw-create-graph))
#+end_src

This creates an empty graph structure. Think of it as a blank canvas.

*** Step 2: Add Nodes

#+begin_src emacs-lisp
(dag-draw-add-node my-graph 'start "Start Here")
#+end_src

- *First argument*: The graph to add to
- *Second argument*: A unique ID (can be symbol or string)
- *Third argument*: The display label (what users see)

The ID is for your code to reference. The label is what appears in the rendered output.

*** Step 3: Connect with Edges

#+begin_src emacs-lisp
(dag-draw-add-edge my-graph 'start 'middle)
#+end_src

This creates a directed edge from ~start~ to ~middle~. The arrow points from the first ID to the second.

*** Step 4: Layout and Render

#+begin_src emacs-lisp
(dag-draw-layout-graph my-graph)
(dag-draw-render-graph my-graph 'ascii)
#+end_src

- ~dag-draw-layout-graph~ runs the GKNV algorithm (assigns positions)
- ~dag-draw-render-graph~ converts positions to visual output

You must layout before rendering. Layout calculates where everything goes; render draws it.

** A Slightly More Complex Example

Let's add some branching to make it interesting:

#+begin_src emacs-lisp
(setq project-graph (dag-draw-create-graph))

;; Add nodes for a project workflow
(dag-draw-add-node project-graph 'plan "Planning")
(dag-draw-add-node project-graph 'design "Design")
(dag-draw-add-node project-graph 'code "Write Code")
(dag-draw-add-node project-graph 'test "Testing")
(dag-draw-add-node project-graph 'docs "Documentation")
(dag-draw-add-node project-graph 'deploy "Deploy")

;; Create dependencies
(dag-draw-add-edge project-graph 'plan 'design)
(dag-draw-add-edge project-graph 'plan 'docs)
(dag-draw-add-edge project-graph 'design 'code)
(dag-draw-add-edge project-graph 'code 'test)
(dag-draw-add-edge project-graph 'test 'deploy)
(dag-draw-add-edge project-graph 'docs 'deploy)

;; Layout and render
(dag-draw-layout-graph project-graph)
(dag-draw-render-graph project-graph 'ascii)
#+end_src

Output:

#+begin_example
     ┌─────────┐
     │Planning │
     └────┬────┘
          │
     ┌────┴──────────────┐
     │                   │
     ▼                   ▼
┌────────┐         ┌──────────────┐
│Design  │         │Documentation │
└────┬───┘         └──────┬───────┘
     │                    │
     ▼                    │
┌──────────────┐          │
│Write Code    │          │
└──────┬───────┘          │
       │                  │
       ▼                  │
┌────────┐                │
│Testing │                │
└────┬───┘                │
     │                    │
     ├────────────────────┘
     │
     ▼
┌────────┐
│Deploy  │
└────────┘
#+end_example

Notice how dag-draw automatically:
- Positioned "Planning" at the top (no dependencies)
- Arranged "Design" and "Documentation" in parallel (both depend only on Planning)
- Minimized crossing lines
- Made edges merge cleanly at "Deploy"

*You specified structure. dag-draw handled layout.*

* Tutorial: From Basics to Advanced
:PROPERTIES:
:DESCRIPTION: Learn to use dag-draw effectively
:CUSTOM_ID: tutorial
:END:

This section teaches you everything you need to use dag-draw effectively, from simple graphs to advanced customization.

** Working with Nodes
:PROPERTIES:
:DESCRIPTION: Creating and customizing nodes
:END:

*** Basic Node Creation

The simplest form uses just an ID and label:

#+begin_src emacs-lisp
(dag-draw-add-node graph 'my-node "Display Label")
#+end_src

The node ID must be unique within the graph. Use symbols or strings:

#+begin_src emacs-lisp
;; Both work
(dag-draw-add-node graph 'node1 "First Node")
(dag-draw-add-node graph "node2" "Second Node")
#+end_src

*Convention*: Use symbols for IDs (easier to type, no quotes needed in most places).

*** Node Labels

Labels can be any string. They're what users see in the rendered output:

#+begin_src emacs-lisp
;; Short labels
(dag-draw-add-node graph 'start "Start")

;; Long labels (will be auto-wrapped)
(dag-draw-add-node graph 'analyze "Analyze Requirements and Create Specifications")

;; Labels with special characters
(dag-draw-add-node graph 'build "Build (v2.0)")
#+end_src

*Note*: Long labels are automatically wrapped to fit within node boundaries. The default constraint is 2 rows × 20 characters maximum.

*** Node Attributes

You can attach custom attributes to nodes for rendering hints:

#+begin_src emacs-lisp
(require 'ht)  ; Hash table library

;; Create attributes hash
(setq node-attrs (ht ("color" "red")
                     ("shape" "diamond")
                     ("style" "bold")))

(dag-draw-add-node graph 'critical "Critical Task" node-attrs)
#+end_src

Attributes are used by renderers (especially SVG) for styling. ASCII rendering ignores most attributes but uses them for semantic meaning in your code.

*** Visual Properties

Visual properties let you style individual nodes to show status, priority, or categories.

**** Quick Example

Show task completion with markers:

#+begin_src emacs-lisp
(require 'ht)

;; Completed task with checkmark
(dag-draw-add-node graph 'done "Research"
  (ht (:ascii-marker "✓ ")))

;; In-progress task with double border
(dag-draw-add-node graph 'active "Implementation"
  (ht (:ascii-highlight t)
      (:ascii-marker "→ ")))

;; SVG with custom colors
(dag-draw-add-node graph 'critical "Fix Bug"
  (ht (:svg-fill "#ff4444")
      (:svg-stroke "#cc0000")
      (:svg-stroke-width 3)))
#+end_src

**** ASCII Visual Properties

*ASCII Markers*: Prepend text to labels

#+begin_src emacs-lisp
(dag-draw-add-node graph 'task1 "Done" (ht (:ascii-marker "✓ ")))
(dag-draw-add-node graph 'task2 "Current" (ht (:ascii-marker "→ ")))
(dag-draw-add-node graph 'task3 "Blocked" (ht (:ascii-marker "✗ ")))
#+end_src

Renders as:
#+begin_example
┌──────────┐
│✓ Done    │
└──────────┘
#+end_example

*ASCII Highlighting*: Double-line borders

#+begin_src emacs-lisp
(dag-draw-add-node graph 'important "Critical"
  (ht (:ascii-highlight t)))
#+end_src

Renders with double borders (~╔═╗~) instead of single (~┌─┐~):
#+begin_example
╔══════════╗
║Critical  ║
╚══════════╝
#+end_example

**** SVG Visual Properties

*Fill Color*: Background color

#+begin_src emacs-lisp
(dag-draw-add-node graph 'success "Passed"
  (ht (:svg-fill "#90ee90")))  ; Light green
#+end_src

*Stroke Color and Width*: Border styling

#+begin_src emacs-lisp
(dag-draw-add-node graph 'warning "Alert"
  (ht (:svg-fill "#ffd700")        ; Gold fill
      (:svg-stroke "#ff8c00")      ; Orange border
      (:svg-stroke-width 2)))      ; Thicker border
#+end_src

**** Multi-Format Properties

Combine ASCII and SVG properties for graphs rendered in both formats:

#+begin_src emacs-lisp
(dag-draw-add-node graph 'done "Complete"
  (ht (:ascii-marker "✓ ")
      (:ascii-highlight nil)
      (:svg-fill "#90ee90")
      (:svg-stroke "#228b22")
      (:svg-stroke-width 2)))
#+end_src

ASCII output: ~✓ Complete~ with checkmark

SVG output: Green background, dark green border

**** Common Patterns

*Traffic Light Status*:
#+begin_src emacs-lisp
;; Good
(ht (:svg-fill "#90ee90"))

;; Warning
(ht (:svg-fill "#ffd700") (:svg-stroke "#ff8c00"))

;; Error
(ht (:svg-fill "#ff4444") (:svg-stroke "#cc0000") (:svg-stroke-width 3))
#+end_src

*Progress Markers*:
#+begin_src emacs-lisp
(ht (:ascii-marker "✓ "))  ; Completed
(ht (:ascii-marker "→ "))  ; Current
(ht (:ascii-marker "○ "))  ; Future
#+end_src

*** Retrieving Nodes

After adding nodes, you can retrieve them:

#+begin_src emacs-lisp
(setq node (dag-draw-get-node graph 'my-node))

;; Access node properties
(dag-draw-node-id node)       ; => 'my-node
(dag-draw-node-label node)    ; => "Display Label"
(dag-draw-node-x-coord node)  ; => nil (before layout) or number (after)
(dag-draw-node-y-coord node)  ; => nil (before layout) or number (after)
(dag-draw-node-rank node)     ; => nil (before layout) or rank number (after)
#+end_src

*Coordinate properties are nil until you call ~dag-draw-layout-graph~.*

** Working with Edges
:PROPERTIES:
:DESCRIPTION: Creating and customizing edges
:END:

*** Basic Edge Creation

Edges connect two nodes by their IDs:

#+begin_src emacs-lisp
(dag-draw-add-edge graph 'node-a 'node-b)
#+end_src

This creates a directed edge from ~node-a~ to ~node-b~. The arrow points from first to second.

*Direction matters*: ~(dag-draw-add-edge graph 'a 'b)~ is NOT the same as ~(dag-draw-add-edge graph 'b 'a)~.

*** Multiple Edges

You can add multiple edges from the same node:

#+begin_src emacs-lisp
;; A depends on both B and C
(dag-draw-add-edge graph 'b 'a)
(dag-draw-add-edge graph 'c 'a)

;; D depends on A
(dag-draw-add-edge graph 'a 'd)
#+end_src

This creates a diamond pattern:

#+begin_example
┌─┐  ┌─┐
│B│  │C│
└┬┘  └┬┘
 │    │
 └─┬──┘
   ▼
  ┌─┐
  │A│
  └┬┘
   │
   ▼
  ┌─┐
  │D│
  └─┘
#+end_example

*** Edge Weights

Weights influence the layout algorithm (higher weights pull nodes closer):

#+begin_src emacs-lisp
;; High-priority dependency (pulls nodes close)
(dag-draw-add-edge graph 'a 'b (ht ("weight" 10)))

;; Low-priority dependency (allows more distance)
(dag-draw-add-edge graph 'a 'c (ht ("weight" 1)))
#+end_src

*Default weight is 1*. Higher weights (5-10) make the algorithm try harder to keep nodes close vertically.

*** Edge Labels

Edges can have labels (useful for documenting relationships):

#+begin_src emacs-lisp
(setq edge-attrs (ht ("label" "requires")))
(dag-draw-add-edge graph 'design 'coding edge-attrs)
#+end_src

*Note*: Edge label rendering support varies by format. SVG supports them well; ASCII may not display them.

*** Edge Constraints

Minimum length constraints force vertical separation:

#+begin_src emacs-lisp
;; Force at least 2 ranks between nodes
(setq edge-attrs (ht ("min-length" 2)))
(dag-draw-add-edge graph 'top 'bottom edge-attrs)
#+end_src

Use this when you need visual separation between certain nodes.

** Layout: The Magic Step
:PROPERTIES:
:DESCRIPTION: Understanding layout and customization
:END:

*** Basic Layout

Layout is simple: just call the function.

#+begin_src emacs-lisp
(dag-draw-layout-graph my-graph)
#+end_src

This runs the four-pass GKNV algorithm and assigns coordinates to all nodes and edges.

*You must layout before rendering.* Rendering requires coordinates that layout provides.

*** What Layout Does

When you call ~dag-draw-layout-graph~, four things happen automatically:

*Pass 1: Ranking (Vertical Levels)*

Assigns each node to a vertical level (rank):

#+begin_example
Rank 0:  [A] [B]        (no dependencies)
Rank 1:  [C] [D]        (depend on rank 0)
Rank 2:  [E]            (depends on rank 1)
#+end_example

Nodes with no incoming edges go at the top. Each subsequent rank depends on previous ranks.

*Pass 2: Ordering (Horizontal Arrangement)*

Within each rank, arranges nodes horizontally to minimize crossing arrows.

The algorithm tries thousands of arrangements to find one with few crossings. This is the hardest computational problem in graph layout.

*Pass 3: Positioning (Exact Coordinates)*

Calculates precise X,Y coordinates that:
- Respect the ordering from Pass 2
- Keep minimum separation between nodes
- Align connected nodes nicely

*Pass 4: Splines (Smooth Edges)*

Generates Bézier curve control points for edges that:
- Route smoothly from source to destination
- Avoid overlapping nodes
- Create professional-looking curves

*** Customizing Spacing

Control how much space appears between elements:

#+begin_src emacs-lisp
;; Create graph with custom spacing
(setq my-graph (dag-draw-create-graph))

;; Set spacing before adding nodes
(setf (dag-draw-graph-node-separation my-graph) 30)  ; horizontal space
(setf (dag-draw-graph-rank-separation my-graph) 50)  ; vertical space

;; Add nodes and edges...
;; Then layout
(dag-draw-layout-graph my-graph)
#+end_src

*Default values*:
- Node separation: 20 units
- Rank separation: 25 units

*Increase these values* if your graphs look cramped. *Decrease them* for more compact output.

*** ASCII vs High-Resolution Layout

dag-draw supports two coordinate modes:

#+begin_src emacs-lisp
;; ASCII mode (default, optimized for terminal output)
(setf (dag-draw-graph-coordinate-mode my-graph) 'ascii)

;; High-resolution mode (for SVG/detailed graphics)
(setf (dag-draw-graph-coordinate-mode my-graph) 'high-res)
#+end_src

*ASCII mode* uses smaller separation values appropriate for character grids. *High-res mode* uses the standard GKNV algorithm spacing.

*Recommendation*: Use default (ASCII) unless you're only generating SVG output.

*** Rank Constraints

Sometimes you want to force certain nodes onto the same level:

#+begin_src emacs-lisp
;; Force nodes 'a and 'b onto the same rank
(setf (dag-draw-graph-rank-sets my-graph)
      '(('a 'b)))
#+end_src

This is advanced usage. Most graphs don't need rank constraints.

** Rendering: From Coordinates to Pictures
:PROPERTIES:
:DESCRIPTION: Producing visual output
:END:

*** ASCII Rendering

ASCII rendering produces box-drawing character output for terminals and plain text:

#+begin_src emacs-lisp
(dag-draw-render-graph my-graph 'ascii)
#+end_src

Returns a string you can insert into buffers or print:

#+begin_src emacs-lisp
(with-current-buffer (get-buffer-create "*Graph*")
  (erase-buffer)
  (insert (dag-draw-render-graph my-graph 'ascii))
  (goto-char (point-min))
  (pop-to-buffer (current-buffer)))
#+end_src

*Best for*:
- Quick previews
- README files
- Source code comments
- Email
- Terminal output

*Requirements*:
- Monospace font
- Unicode box-drawing character support

*** SVG Rendering

SVG rendering produces scalable vector graphics:

#+begin_src emacs-lisp
(dag-draw-render-graph my-graph 'svg)
#+end_src

Returns an SVG string you can save to a file:

#+begin_src emacs-lisp
(with-temp-file "~/my-graph.svg"
  (insert (dag-draw-render-graph my-graph 'svg)))
#+end_src

Or display in Emacs (if your Emacs build supports SVG):

#+begin_src emacs-lisp
(with-current-buffer (get-buffer-create "*Graph SVG*")
  (erase-buffer)
  (insert-image (create-image
                 (dag-draw-render-graph my-graph 'svg)
                 'svg t))
  (pop-to-buffer (current-buffer)))
#+end_src

*Best for*:
- Documentation websites
- Presentations
- High-quality printouts
- Scalable diagrams

*Advantages*:
- Crisp at any zoom level
- Smooth curves
- Customizable styling
- Embeddable in HTML

*** DOT Rendering

DOT format is Graphviz's input language:

#+begin_src emacs-lisp
(dag-draw-render-graph my-graph 'dot)
#+end_src

This outputs DOT language source that you can process with Graphviz tools.

*Use this when*:
- You need Graphviz-specific features
- You want to post-process with Graphviz
- You're debugging layout differences

*** Choosing the Right Format

#+begin_example
Use ASCII when:
  - Quick preview needed
  - Terminal/text-only environment
  - Including in code comments
  - Email or plain text documentation

Use SVG when:
  - Presentation quality matters
  - Web publishing
  - Need scalability
  - Want custom styling

Use DOT when:
  - Interfacing with Graphviz
  - Need Graphviz-specific features
  - Comparing layouts
#+end_example

** Practical Examples
:PROPERTIES:
:DESCRIPTION: Real-world use cases
:END:

*** Example 1: Course Prerequisites

#+begin_src emacs-lisp
(setq course-graph (dag-draw-create-graph))

;; First year courses
(dag-draw-add-node course-graph 'cs101 "Intro to CS")
(dag-draw-add-node course-graph 'math101 "Calculus I")
(dag-draw-add-node course-graph 'math102 "Calculus II")

;; Second year courses
(dag-draw-add-node course-graph 'cs201 "Data Structures")
(dag-draw-add-node course-graph 'cs202 "Algorithms")
(dag-draw-add-node course-graph 'math201 "Linear Algebra")

;; Third year courses
(dag-draw-add-node course-graph 'cs301 "Machine Learning")

;; Prerequisites
(dag-draw-add-edge course-graph 'cs101 'cs201)
(dag-draw-add-edge course-graph 'cs201 'cs202)
(dag-draw-add-edge course-graph 'math101 'math102)
(dag-draw-add-edge course-graph 'math102 'math201)
(dag-draw-add-edge course-graph 'cs202 'cs301)
(dag-draw-add-edge course-graph 'math201 'cs301)

(dag-draw-layout-graph course-graph)
(dag-draw-render-graph course-graph 'ascii)
#+end_src

*** Example 2: Build Dependencies

#+begin_src emacs-lisp
(setq build-graph (dag-draw-create-graph))

;; Source files
(dag-draw-add-node build-graph 'utils-h "utils.h")
(dag-draw-add-node build-graph 'utils-c "utils.c")
(dag-draw-add-node build-graph 'main-c "main.c")

;; Object files
(dag-draw-add-node build-graph 'utils-o "utils.o")
(dag-draw-add-node build-graph 'main-o "main.o")

;; Executable
(dag-draw-add-node build-graph 'program "program")

;; Dependencies
(dag-draw-add-edge build-graph 'utils-h 'utils-c)
(dag-draw-add-edge build-graph 'utils-c 'utils-o)
(dag-draw-add-edge build-graph 'utils-h 'main-c)
(dag-draw-add-edge build-graph 'main-c 'main-o)
(dag-draw-add-edge build-graph 'utils-o 'program)
(dag-draw-add-edge build-graph 'main-o 'program)

(dag-draw-layout-graph build-graph)
(dag-draw-render-graph build-graph 'ascii)
#+end_src

*** Example 3: Project Task Dependencies

#+begin_src emacs-lisp
(defun visualize-project-tasks ()
  "Create a visualization of project tasks."
  (let ((graph (dag-draw-create-graph)))

    ;; Define tasks
    (dag-draw-add-node graph 'requirements "Requirements")
    (dag-draw-add-node graph 'architecture "Architecture")
    (dag-draw-add-node graph 'ui-design "UI Design")
    (dag-draw-add-node graph 'backend "Backend Dev")
    (dag-draw-add-node graph 'frontend "Frontend Dev")
    (dag-draw-add-node graph 'integration "Integration")
    (dag-draw-add-node graph 'testing "Testing")
    (dag-draw-add-node graph 'deployment "Deployment")

    ;; Define dependencies
    (dag-draw-add-edge graph 'requirements 'architecture)
    (dag-draw-add-edge graph 'requirements 'ui-design)
    (dag-draw-add-edge graph 'architecture 'backend)
    (dag-draw-add-edge graph 'architecture 'frontend)
    (dag-draw-add-edge graph 'ui-design 'frontend)
    (dag-draw-add-edge graph 'backend 'integration)
    (dag-draw-add-edge graph 'frontend 'integration)
    (dag-draw-add-edge graph 'integration 'testing)
    (dag-draw-add-edge graph 'testing 'deployment)

    ;; Layout and display
    (dag-draw-layout-graph graph)

    ;; Insert into a buffer
    (with-current-buffer (get-buffer-create "*Project Tasks*")
      (erase-buffer)
      (insert "Project Task Dependencies\n")
      (insert "========================\n\n")
      (insert (dag-draw-render-graph graph 'ascii))
      (goto-char (point-min))
      (pop-to-buffer (current-buffer)))))
#+end_src

Call it with:

#+begin_src emacs-lisp
(visualize-project-tasks)
#+end_src

* Reference
:PROPERTIES:
:DESCRIPTION: Complete API documentation
:CUSTOM_ID: reference
:END:

This section documents every public function and variable in dag-draw.

** Graph Functions
:PROPERTIES:
:DESCRIPTION: Creating and manipulating graphs
:END:

*** dag-draw-create-graph

#+begin_src emacs-lisp
(dag-draw-create-graph &optional attributes)
#+end_src

Create a new empty directed graph.

*Arguments*:
- ~attributes~ (optional): Hash table of graph-level attributes

*Returns*: A new ~dag-draw-graph~ structure

*Example*:
#+begin_src emacs-lisp
;; Basic graph
(setq g (dag-draw-create-graph))

;; Graph with attributes
(setq g (dag-draw-create-graph (ht ("name" "My Graph")
                                    ("type" "workflow"))))
#+end_src

*** dag-draw-layout-graph

#+begin_src emacs-lisp
(dag-draw-layout-graph graph)
#+end_src

Run the GKNV layout algorithm on a graph.

This function modifies the graph in-place, assigning coordinates to nodes and generating spline points for edges.

*Arguments*:
- ~graph~: A ~dag-draw-graph~ structure

*Returns*: The modified graph (for chaining)

*Side effects*: Sets coordinates on all nodes and spline points on all edges

*Example*:
#+begin_src emacs-lisp
(dag-draw-add-node g 'a "A")
(dag-draw-add-node g 'b "B")
(dag-draw-add-edge g 'a 'b)
(dag-draw-layout-graph g)  ; Now nodes have coordinates
#+end_src

*Note*: You must call this before rendering.

** Node Functions
:PROPERTIES:
:DESCRIPTION: Working with nodes
:END:

*** dag-draw-add-node

#+begin_src emacs-lisp
(dag-draw-add-node graph node-id &optional label attributes)
#+end_src

Add a node to a graph.

*Arguments*:
- ~graph~: The graph to add to
- ~node-id~: Unique identifier (symbol or string)
- ~label~ (optional): Display label (defaults to node-id as string)
- ~attributes~ (optional): Hash table of node attributes

*Returns*: The created node structure

*Example*:
#+begin_src emacs-lisp
;; Minimal
(dag-draw-add-node graph 'my-node)

;; With label
(dag-draw-add-node graph 'task1 "First Task")

;; With attributes
(dag-draw-add-node graph 'critical "Critical"
                   (ht ("color" "red")
                       ("priority" "high")))
#+end_src

*Note*: Node IDs must be unique within a graph. Adding a node with an existing ID replaces the old node.

*** dag-draw-get-node

#+begin_src emacs-lisp
(dag-draw-get-node graph node-id)
#+end_src

Retrieve a node by ID.

*Arguments*:
- ~graph~: The graph to search
- ~node-id~: The node's unique identifier

*Returns*: The node structure, or ~nil~ if not found

*Example*:
#+begin_src emacs-lisp
(setq node (dag-draw-get-node graph 'my-node))
(when node
  (message "Label: %s" (dag-draw-node-label node)))
#+end_src

*** Node Accessors

**** dag-draw-node-id

#+begin_src emacs-lisp
(dag-draw-node-id node)
#+end_src

Get the node's unique identifier.

*Returns*: The node ID (symbol or string)

**** dag-draw-node-label

#+begin_src emacs-lisp
(dag-draw-node-label node)
#+end_src

Get the node's display label.

*Returns*: String label

**** dag-draw-node-x-coord

#+begin_src emacs-lisp
(dag-draw-node-x-coord node)
#+end_src

Get the node's X coordinate.

*Returns*: Number (after layout), or ~nil~ (before layout)

**** dag-draw-node-y-coord

#+begin_src emacs-lisp
(dag-draw-node-y-coord node)
#+end_src

Get the node's Y coordinate.

*Returns*: Number (after layout), or ~nil~ (before layout)

**** dag-draw-node-rank

#+begin_src emacs-lisp
(dag-draw-node-rank node)
#+end_src

Get the node's assigned rank (vertical level).

*Returns*: Integer rank (after layout), or ~nil~ (before layout)

Rank 0 is the top level. Higher ranks are lower in the visual output.

**** dag-draw-node-order

#+begin_src emacs-lisp
(dag-draw-node-order node)
#+end_src

Get the node's order within its rank.

*Returns*: Integer order (after layout), or ~nil~ (before layout)

Order 0 is leftmost. Higher orders are further right.

**** dag-draw-node-attributes

#+begin_src emacs-lisp
(dag-draw-node-attributes node)
#+end_src

Get the node's attribute hash table.

*Returns*: Hash table (possibly empty)

*Example*:
#+begin_src emacs-lisp
(setq attrs (dag-draw-node-attributes node))
(ht-get attrs "color")  ; => "red"
#+end_src

**** Visual Properties Attributes

Node attributes support visual styling through prefixed keywords:

***** ASCII Visual Properties

| Attribute | Type | Description | Example |
|-----------+------+-------------+---------|
| ~:ascii-highlight~ | boolean | Render with double-line borders (╔═╗) | ~t~ |
| ~:ascii-marker~ | string | Prepend marker to label | ~"✓ "~, ~"→ "~ |

***** SVG Visual Properties

| Attribute | Type | Description | Example |
|-----------+------+-------------+---------|
| ~:svg-fill~ | string | Fill color (CSS) | ~"#ff5733"~ |
| ~:svg-stroke~ | string | Border color (CSS) | ~"#0000ff"~ |
| ~:svg-stroke-width~ | number | Border thickness (pixels) | ~2~, ~3~ |

*Example*:
#+begin_src emacs-lisp
;; ASCII: Double border with checkmark
(dag-draw-add-node graph 'done "Task"
  (ht (:ascii-highlight t)
      (:ascii-marker "✓ ")))

;; SVG: Green background, dark green border
(dag-draw-add-node graph 'success "Build"
  (ht (:svg-fill "#90ee90")
      (:svg-stroke "#228b22")
      (:svg-stroke-width 2)))

;; Both formats
(dag-draw-add-node graph 'active "Current"
  (ht (:ascii-highlight t)
      (:ascii-marker "→ ")
      (:svg-fill "#ffd700")
      (:svg-stroke "#ff8c00")))
#+end_src

*Notes*:
- ASCII attributes only affect ASCII rendering
- SVG attributes only affect SVG rendering
- Combine both for multi-format support
- Invalid attributes are silently ignored

** Edge Functions
:PROPERTIES:
:DESCRIPTION: Working with edges
:END:

*** dag-draw-add-edge

#+begin_src emacs-lisp
(dag-draw-add-edge graph from-id to-id &optional attributes)
#+end_src

Add a directed edge to a graph.

*Arguments*:
- ~graph~: The graph to add to
- ~from-id~: Source node ID
- ~to-id~: Destination node ID
- ~attributes~ (optional): Hash table of edge attributes

*Returns*: The created edge structure

*Example*:
#+begin_src emacs-lisp
;; Basic edge
(dag-draw-add-edge graph 'a 'b)

;; Edge with weight
(dag-draw-add-edge graph 'a 'c (ht ("weight" 5)))

;; Edge with label
(dag-draw-add-edge graph 'a 'd (ht ("label" "requires")))
#+end_src

*Note*: Both nodes must exist in the graph before adding an edge.

*** dag-draw-get-edges

#+begin_src emacs-lisp
(dag-draw-get-edges graph)
#+end_src

Get all edges in a graph.

*Arguments*:
- ~graph~: The graph

*Returns*: List of edge structures

*Example*:
#+begin_src emacs-lisp
(dolist (edge (dag-draw-get-edges graph))
  (message "Edge: %s -> %s"
           (dag-draw-edge-from-node edge)
           (dag-draw-edge-to-node edge)))
#+end_src

*** Edge Accessors

**** dag-draw-edge-from-node

#+begin_src emacs-lisp
(dag-draw-edge-from-node edge)
#+end_src

Get the source node ID.

*Returns*: Node ID (symbol or string)

**** dag-draw-edge-to-node

#+begin_src emacs-lisp
(dag-draw-edge-to-node edge)
#+end_src

Get the destination node ID.

*Returns*: Node ID (symbol or string)

**** dag-draw-edge-weight

#+begin_src emacs-lisp
(dag-draw-edge-weight edge)
#+end_src

Get the edge weight.

*Returns*: Number (default: 1)

Higher weights make the layout algorithm try harder to keep nodes close together vertically.

**** dag-draw-edge-min-length

#+begin_src emacs-lisp
(dag-draw-edge-min-length edge)
#+end_src

Get the minimum length constraint.

*Returns*: Integer (default: 1)

Minimum number of ranks between source and destination nodes.

**** dag-draw-edge-spline-points

#+begin_src emacs-lisp
(dag-draw-edge-spline-points edge)
#+end_src

Get the Bézier curve control points.

*Returns*: List of (x y) coordinate pairs (after layout), or ~nil~ (before layout)

These points define the smooth curve of the edge in the rendered output.

**** dag-draw-edge-attributes

#+begin_src emacs-lisp
(dag-draw-edge-attributes edge)
#+end_src

Get the edge's attribute hash table.

*Returns*: Hash table (possibly empty)

** Rendering Functions
:PROPERTIES:
:DESCRIPTION: Producing visual output
:END:

*** dag-draw-render-graph

#+begin_src emacs-lisp
(dag-draw-render-graph graph format)
#+end_src

Render a graph to a specific format.

*Arguments*:
- ~graph~: The graph to render (must be laid out first)
- ~format~: Output format symbol (~'ascii~, ~'svg~, or ~'dot~)

*Returns*: String containing the rendered output

*Example*:
#+begin_src emacs-lisp
;; ASCII rendering
(setq ascii-output (dag-draw-render-graph graph 'ascii))

;; SVG rendering
(setq svg-output (dag-draw-render-graph graph 'svg))

;; DOT rendering
(setq dot-output (dag-draw-render-graph graph 'dot))
#+end_src

*Error*: Signals an error if the graph hasn't been laid out yet.

** Configuration Variables
:PROPERTIES:
:DESCRIPTION: Customization options
:END:

*** dag-draw-default-node-separation

Default minimum horizontal separation between nodes.

*Type*: Integer

*Default*: 20

Used when creating graphs in high-resolution mode. Larger values create more spacing.

*Example*:
#+begin_src emacs-lisp
(setq dag-draw-default-node-separation 30)
#+end_src

*** dag-draw-default-rank-separation

Default minimum vertical separation between ranks.

*Type*: Integer

*Default*: 25

Used when creating graphs in high-resolution mode. Larger values create more spacing.

*Example*:
#+begin_src emacs-lisp
(setq dag-draw-default-rank-separation 50)
#+end_src

*** dag-draw-ascii-node-separation

Horizontal spacing between nodes in ASCII mode (characters).

*Type*: Integer

*Default*: 6

Used when coordinate-mode is ~'ascii~. This is the number of characters between adjacent nodes.

*Example*:
#+begin_src emacs-lisp
(setq dag-draw-ascii-node-separation 10)
#+end_src

*** dag-draw-ascii-rank-separation

Vertical spacing between ranks in ASCII mode (rows).

*Type*: Integer

*Default*: 5

Used when coordinate-mode is ~'ascii~. This is the number of rows between adjacent ranks.

*Example*:
#+begin_src emacs-lisp
(setq dag-draw-ascii-rank-separation 7)
#+end_src

*** dag-draw-default-output-format

Default output format for rendered graphs.

*Type*: Symbol (~'ascii~, ~'svg~, or ~'dot~)

*Default*: ~'svg~

*Example*:
#+begin_src emacs-lisp
(setq dag-draw-default-output-format 'ascii)
#+end_src

** Graph Structure Accessors
:PROPERTIES:
:DESCRIPTION: Direct graph structure access
:END:

*** dag-draw-graph-nodes

#+begin_src emacs-lisp
(dag-draw-graph-nodes graph)
#+end_src

Get the hash table of nodes.

*Returns*: Hash table mapping node IDs to node structures

*Example*:
#+begin_src emacs-lisp
(setq nodes-table (dag-draw-graph-nodes graph))
(ht-get nodes-table 'my-node)  ; Get a specific node
#+end_src

*** dag-draw-graph-edges

#+begin_src emacs-lisp
(dag-draw-graph-edges graph)
#+end_src

Get the list of edges.

*Returns*: List of edge structures

*** dag-draw-graph-node-separation

#+begin_src emacs-lisp
(dag-draw-graph-node-separation graph)
#+end_src

Get or set the horizontal node separation for this graph.

*Returns*: Integer

*Settable*: Use ~setf~ to change:
#+begin_src emacs-lisp
(setf (dag-draw-graph-node-separation graph) 30)
#+end_src

*** dag-draw-graph-rank-separation

#+begin_src emacs-lisp
(dag-draw-graph-rank-separation graph)
#+end_src

Get or set the vertical rank separation for this graph.

*Returns*: Integer

*Settable*: Use ~setf~ to change:
#+begin_src emacs-lisp
(setf (dag-draw-graph-rank-separation graph) 50)
#+end_src

*** dag-draw-graph-coordinate-mode

#+begin_src emacs-lisp
(dag-draw-graph-coordinate-mode graph)
#+end_src

Get or set the coordinate system mode.

*Returns*: Symbol (~'ascii~ or ~'high-res~)

*Settable*: Use ~setf~ to change:
#+begin_src emacs-lisp
(setf (dag-draw-graph-coordinate-mode graph) 'high-res)
#+end_src

** Data Structure Details
:PROPERTIES:
:DESCRIPTION: Understanding the internal structures
:END:

*** Node Structure

The ~dag-draw-node~ structure has these slots:

- ~id~ - Unique identifier (symbol or string)
- ~label~ - Display label (string)
- ~x-size~ - Width of node bounding box (integer)
- ~y-size~ - Height of node bounding box (integer)
- ~x-coord~ - X coordinate (number, nil before layout)
- ~y-coord~ - Y coordinate (number, nil before layout)
- ~rank~ - Assigned rank (integer, nil before layout)
- ~order~ - Order within rank (integer, nil before layout)
- ~virtual-p~ - Whether this is a virtual node (boolean)
- ~attributes~ - Custom attributes (hash table)

*** Edge Structure

The ~dag-draw-edge~ structure has these slots:

- ~from-node~ - Source node ID
- ~to-node~ - Destination node ID
- ~weight~ - Edge weight (number, default: 1)
- ~min-length~ - Minimum length constraint (integer, default: 1)
- ~label~ - Optional edge label (string)
- ~spline-points~ - Bézier control points (list, nil before layout)
- ~label-position~ - Position for edge label (coordinate pair)
- ~attributes~ - Custom attributes (hash table)

*** Graph Structure

The ~dag-draw-graph~ structure has these slots:

- ~nodes~ - Hash table mapping IDs to nodes
- ~edges~ - List of edge structures
- ~node-separation~ - Horizontal spacing (integer)
- ~rank-separation~ - Vertical spacing (integer)
- ~max-rank~ - Maximum assigned rank (integer, nil before layout)
- ~rank-sets~ - User-specified rank constraints (list)
- ~adjusted-positions~ - Adjusted coordinates (hash table)
- ~coordinate-mode~ - Coordinate system (~'ascii~ or ~'high-res~)
- ~attributes~ - Graph-level attributes (hash table)

* Troubleshooting
:PROPERTIES:
:DESCRIPTION: Common problems and solutions
:CUSTOM_ID: troubleshooting
:END:

** Graph has cycles

*Error message*:
#+begin_example
Error: Graph contains a cycle
#+end_example

*Problem*: Your graph has a circular dependency (A → B → C → A).

*Solution*: DAGs must be acyclic. Find and remove the edge that creates the cycle.

*How to debug*:
#+begin_src emacs-lisp
;; Manual inspection: print all edges
(dolist (edge (dag-draw-get-edges graph))
  (message "%s -> %s"
           (dag-draw-edge-from-node edge)
           (dag-draw-edge-to-node edge)))

;; Look for cycles in the output
#+end_src

** Node not found

*Error message*:
#+begin_example
Error: Node 'foo not found in graph
#+end_example

*Problem*: You're trying to add an edge to a node that doesn't exist.

*Solution*: Add nodes before adding edges that reference them.

*Wrong order*:
#+begin_src emacs-lisp
(dag-draw-add-edge graph 'a 'b)  ; ERROR: nodes don't exist yet
(dag-draw-add-node graph 'a "A")
(dag-draw-add-node graph 'b "B")
#+end_src

*Correct order*:
#+begin_src emacs-lisp
(dag-draw-add-node graph 'a "A")
(dag-draw-add-node graph 'b "B")
(dag-draw-add-edge graph 'a 'b)  ; Now it works
#+end_src

** Nodes overlap in ASCII output

*Problem*: Node boxes overlap or text collides in ASCII rendering.

*Solution*: Increase ASCII node separation:

#+begin_src emacs-lisp
(setq dag-draw-ascii-node-separation 10)  ; Default is 6
#+end_src

Or set it per-graph:
#+begin_src emacs-lisp
(setf (dag-draw-graph-node-separation graph) 10)
#+end_src

** Graph looks cramped

*Problem*: Everything is squished together.

*Solution 1*: Increase separation values before layout:

#+begin_src emacs-lisp
;; For ASCII
(setq dag-draw-ascii-node-separation 10)
(setq dag-draw-ascii-rank-separation 7)

;; For high-res/SVG
(setq dag-draw-default-node-separation 40)
(setq dag-draw-default-rank-separation 60)
#+end_src

*Solution 2*: Set per-graph:

#+begin_src emacs-lisp
(setf (dag-draw-graph-node-separation graph) 40)
(setf (dag-draw-graph-rank-separation graph) 60)
(dag-draw-layout-graph graph)  ; Re-layout with new spacing
#+end_src

** Graph looks too spread out

*Problem*: Too much white space between nodes.

*Solution*: Decrease separation values:

#+begin_src emacs-lisp
;; For ASCII
(setq dag-draw-ascii-node-separation 4)
(setq dag-draw-ascii-rank-separation 3)

;; For high-res/SVG
(setq dag-draw-default-node-separation 15)
(setq dag-draw-default-rank-separation 20)
#+end_src

** Must call layout before rendering

*Error message*:
#+begin_example
Error: Graph must be laid out before rendering
#+end_example

*Problem*: You called ~dag-draw-render-graph~ without calling ~dag-draw-layout-graph~ first.

*Solution*: Always layout before rendering:

#+begin_src emacs-lisp
;; WRONG
(dag-draw-render-graph graph 'ascii)  ; ERROR

;; RIGHT
(dag-draw-layout-graph graph)
(dag-draw-render-graph graph 'ascii)  ; Works
#+end_src

** ASCII output shows broken characters

*Problem*: Box-drawing characters appear as question marks or broken symbols.

*Solution 1*: Ensure your terminal/buffer supports Unicode:

#+begin_src emacs-lisp
;; Check your buffer encoding
(describe-current-coding-system)

;; Set UTF-8 if needed
(set-buffer-file-coding-system 'utf-8-unix)
#+end_src

*Solution 2*: Use a font that supports box-drawing characters:
- Courier New
- DejaVu Sans Mono
- Consolas
- Monaco
- Any modern monospace font

** SVG doesn't display in Emacs

*Problem*: SVG output is generated but doesn't show as an image.

*Cause*: Your Emacs build doesn't have SVG support compiled in.

*Check SVG support*:
#+begin_src emacs-lisp
(image-type-available-p 'svg)  ; Should return t
#+end_src

*Solution*: If it returns ~nil~, either:
1. Rebuild Emacs with SVG support (requires librsvg)
2. Save SVG to a file and view in a web browser:

#+begin_src emacs-lisp
(with-temp-file "~/graph.svg"
  (insert (dag-draw-render-graph graph 'svg)))
;; Then open graph.svg in Firefox/Chrome
#+end_src

** Performance is slow for large graphs

*Problem*: Layout takes a long time for graphs with many nodes.

*Expected performance*:
- 100 nodes: <1 second
- 500 nodes: ~5 seconds
- 1000+ nodes: May take minutes

*Solutions*:

1. *Simplify the graph*: Combine related nodes
2. *Remove transitive edges*: If A→B and B→C, you don't need A→C
3. *Use subgraphs*: Break into smaller related graphs
4. *Cache layouts*: Layout once, render multiple times

#+begin_src emacs-lisp
;; Layout once
(dag-draw-layout-graph big-graph)

;; Render multiple times (fast)
(dag-draw-render-graph big-graph 'ascii)
(dag-draw-render-graph big-graph 'svg)
#+end_src

** Edges cross when they shouldn't

*Problem*: The layout has crossing edges that look messy.

*Explanation*: The GKNV algorithm minimizes crossings using heuristics, but it's not perfect. Some crossings are unavoidable in complex graphs.

*Solutions*:

1. *Accept it*: Some graphs inherently require crossings
2. *Adjust edge weights*: Higher weights keep nodes closer

#+begin_src emacs-lisp
;; Increase weight to pull nodes together
(dag-draw-add-edge graph 'a 'b (ht ("weight" 10)))
#+end_src

3. *Reorder manually*: Use rank constraints to force certain arrangements

#+begin_src emacs-lisp
;; Force 'a and 'b on the same rank
(setf (dag-draw-graph-rank-sets graph) '(('a 'b)))
#+end_src

4. *Simplify*: Fewer nodes and edges = fewer crossings

* Advanced Topics
:PROPERTIES:
:DESCRIPTION: Advanced usage and customization
:CUSTOM_ID: advanced
:END:

** Understanding the GKNV Algorithm

dag-draw implements the complete GKNV algorithm from the 1993 paper. Understanding the algorithm helps you use the library more effectively.

*** The Four Passes

Each pass has a specific job:

*Pass 1: Ranking (Vertical Assignment)*

*Goal*: Assign each node to a vertical level (rank).

*Method*: Network simplex optimization that minimizes total edge length.

*Constraints*:
- Nodes with no incoming edges get rank 0 (top)
- Each edge must go from a lower rank to a higher rank
- Minimize the sum of edge lengths

*User control*: You can force nodes onto the same rank with ~rank-sets~.

*Pass 2: Ordering (Horizontal Arrangement)*

*Goal*: Within each rank, arrange nodes left-to-right to minimize edge crossings.

*Method*: Weighted median heuristic with local transposition.

*Why it's hard*: This is an NP-complete problem. The algorithm uses heuristics that work well in practice but don't guarantee optimal results.

*User control*: Limited. The algorithm decides the order automatically.

*Pass 3: Positioning (Coordinate Assignment)*

*Goal*: Calculate exact X,Y coordinates for each node.

*Method*: Constructs an auxiliary graph and runs another network simplex optimization.

*Constraints*:
- Respect the ordering from Pass 2
- Maintain minimum separation between nodes
- Align edges nicely when possible

*User control*: Adjust separation values before layout.

*Pass 4: Splines (Edge Drawing)*

*Goal*: Generate smooth Bézier curves for edges.

*Method*: Calculates control points that route edges around nodes.

*Result*: Professional-looking curves that avoid overlapping nodes.

*User control*: None. This is purely algorithmic.

*** Why This Algorithm?

Other layout algorithms exist (force-directed, circular, etc.), but GKNV is optimal for hierarchical DAGs because:

1. *Respects hierarchy*: Graphs flow in a consistent direction
2. *Minimizes crossings*: Uses sophisticated heuristics proven in practice
3. *Fast*: Polynomial time complexity handles large graphs
4. *Extensible*: Each pass can be customized independently

** Custom Renderers

You can create custom renderers for new output formats.

*** Renderer Interface

A renderer is a function that takes a graph and returns a string:

#+begin_src emacs-lisp
(defun my-custom-renderer (graph)
  "Render GRAPH to my custom format."
  ;; Access laid-out nodes
  (let ((nodes (ht-values (dag-draw-graph-nodes graph)))
        (edges (dag-draw-graph-edges graph)))
    ;; Generate output based on node coordinates and edge splines
    (my-format-output nodes edges)))
#+end_src

*** Accessing Layout Information

After layout, each node has coordinates:

#+begin_src emacs-lisp
(defun print-node-positions (graph)
  "Print all node positions."
  (ht-each
   (lambda (id node)
     (message "Node %s: (%d, %d)"
              id
              (dag-draw-node-x-coord node)
              (dag-draw-node-y-coord node)))
   (dag-draw-graph-nodes graph)))
#+end_src

And each edge has spline points:

#+begin_src emacs-lisp
(defun print-edge-curves (graph)
  "Print all edge spline points."
  (dolist (edge (dag-draw-graph-edges graph))
    (message "Edge %s -> %s: %S"
             (dag-draw-edge-from-node edge)
             (dag-draw-edge-to-node edge)
             (dag-draw-edge-spline-points edge))))
#+end_src

*** Example: Simple Text Renderer

#+begin_src emacs-lisp
(defun dag-draw-render-simple-text (graph)
  "Simple text-only renderer (no graphics)."
  (let ((output ""))
    ;; List nodes by rank
    (ht-each
     (lambda (id node)
       (setq output
             (concat output
                     (format "Node %s (rank %d, order %d): %s\n"
                             id
                             (dag-draw-node-rank node)
                             (dag-draw-node-order node)
                             (dag-draw-node-label node)))))
     (dag-draw-graph-nodes graph))

    ;; List edges
    (setq output (concat output "\nEdges:\n"))
    (dolist (edge (dag-draw-graph-edges graph))
      (setq output
            (concat output
                    (format "  %s -> %s\n"
                            (dag-draw-edge-from-node edge)
                            (dag-draw-edge-to-node edge)))))
    output))
#+end_src

** Integration Examples

*** With Org Mode

Generate graphs from org-mode data:

#+begin_src emacs-lisp
(defun org-visualize-dependencies ()
  "Visualize current subtree's task dependencies."
  (interactive)
  (let ((graph (dag-draw-create-graph))
        (tasks '()))
    ;; Collect tasks from current subtree
    (org-map-entries
     (lambda ()
       (let ((id (org-id-get-create))
             (heading (org-get-heading t t t t)))
         (dag-draw-add-node graph (intern id) heading)
         (push (cons id heading) tasks)))
     nil 'tree)

    ;; Add edges based on org-edna dependencies
    ;; (simplified example)
    (org-map-entries
     (lambda ()
       (let ((id (org-id-get))
             (deps (org-entry-get nil "BLOCKER")))
         (when deps
           (dolist (dep (split-string deps))
             (dag-draw-add-edge graph (intern dep) (intern id))))))
     nil 'tree)

    ;; Layout and display
    (dag-draw-layout-graph graph)
    (with-current-buffer (get-buffer-create "*Task Dependencies*")
      (erase-buffer)
      (insert (dag-draw-render-graph graph 'ascii))
      (pop-to-buffer (current-buffer)))))
#+end_src

*** With Project Management

Track project dependencies:

#+begin_src emacs-lisp
(defvar my-project-tasks
  '((requirements . "Requirements")
    (design . "Design")
    (coding . "Coding")
    (testing . "Testing")
    (deploy . "Deployment"))
  "Project tasks.")

(defvar my-project-dependencies
  '((requirements design)
    (design coding)
    (coding testing)
    (testing deploy))
  "Task dependencies as (from to) pairs.")

(defun visualize-project ()
  "Show project task dependencies."
  (interactive)
  (let ((graph (dag-draw-create-graph)))
    ;; Add tasks as nodes
    (dolist (task my-project-tasks)
      (dag-draw-add-node graph (car task) (cdr task)))

    ;; Add dependencies as edges
    (dolist (dep my-project-dependencies)
      (dag-draw-add-edge graph (car dep) (cadr dep)))

    ;; Layout and render
    (dag-draw-layout-graph graph)
    (message "%s" (dag-draw-render-graph graph 'ascii))))
#+end_src

** Performance Optimization

*** Caching Layouts

If you render the same graph multiple times, layout once:

#+begin_src emacs-lisp
;; Expensive (layouts every time)
(dotimes (i 10)
  (dag-draw-layout-graph graph)
  (dag-draw-render-graph graph 'ascii))

;; Efficient (layouts once)
(dag-draw-layout-graph graph)
(dotimes (i 10)
  (dag-draw-render-graph graph 'ascii))
#+end_src

*** Incremental Updates

For dynamic graphs that change frequently, consider:

1. Keep the graph structure
2. Modify only what changed
3. Re-layout when needed
4. Render on demand

#+begin_src emacs-lisp
(defvar my-dynamic-graph (dag-draw-create-graph))

(defun add-task (id label &optional deps)
  "Add a task to the dynamic graph."
  (dag-draw-add-node my-dynamic-graph id label)
  (dolist (dep deps)
    (dag-draw-add-edge my-dynamic-graph dep id)))

(defun show-current-graph ()
  "Display the current state."
  (dag-draw-layout-graph my-dynamic-graph)
  (message "%s" (dag-draw-render-graph my-dynamic-graph 'ascii)))

;; Use it
(add-task 'start "Start")
(add-task 'middle "Middle" '(start))
(add-task 'end "End" '(middle))
(show-current-graph)
#+end_src

** Coordinate Systems

dag-draw supports two coordinate systems:

*** ASCII Mode (Default)

Optimized for character grid output:
- Uses smaller separation values
- Coordinates are integers
- Designed for 80-column terminals

#+begin_src emacs-lisp
(setf (dag-draw-graph-coordinate-mode graph) 'ascii)
#+end_src

*** High-Resolution Mode

Optimized for SVG and detailed graphics:
- Uses larger separation values
- Coordinates are floats
- Designed for scalable output

#+begin_src emacs-lisp
(setf (dag-draw-graph-coordinate-mode graph) 'high-res)
#+end_src

*** When to Use Which

*Use ASCII mode when*:
- Primarily rendering to ASCII
- Terminal output
- Want compact layout
- Working with small graphs

*Use high-res mode when*:
- Primarily rendering to SVG
- Need precise positioning
- Creating publication-quality output
- Large graphs with many nodes

* Contributing
:PROPERTIES:
:DESCRIPTION: How to contribute to dag-draw
:END:

** Development Setup

Clone the repository:

#+begin_src bash
git clone https://github.com/example/dag-draw.el.git
cd dag-draw.el
#+end_src

Install development dependencies:

#+begin_src bash
eldev test  # Runs test suite
#+end_src

** Testing

dag-draw uses Test-Driven Development with Buttercup:

#+begin_src bash
# Run all tests
eldev test

# Run specific test file
eldev test test/dag-draw-core-test.el

# Run with debugging output
eldev -dtT test
#+end_src

** Code Style

- Follow standard Emacs Lisp conventions
- Use ~lexical-binding: t~
- Document all public functions with docstrings
- Keep functions small and focused
- Write tests before implementation

** Pull Requests

1. Fork the repository
2. Create a feature branch
3. Write tests that fail
4. Implement the feature
5. Ensure all tests pass
6. Submit a pull request

** Reporting Bugs

File issues at: https://github.com/example/dag-draw.el/issues

Include:
- Emacs version (~M-x emacs-version~)
- dag-draw version
- Minimal reproduction case
- Expected vs actual behavior

* Index
:PROPERTIES:
:INDEX: cp
:DESCRIPTION: Complete index
:END:

* Function Index
:PROPERTIES:
:INDEX: fn
:END:

* Variable Index
:PROPERTIES:
:INDEX: vr
:END:
