 The GKNV Four-Pass Algorithm - ELISP IMPLEMENTATION MAPPING

 The GKNV algorithm consists of four sequential passes that transform a directed acyclic graph into a visual representation:

 Pass 1: Cycle Removal and Ranking
 FUNCTION: `dag-draw-rank-graph` in dag-draw-rank.el
 ENTRY POINT: Called from `dag-draw-layout-graph` in dag-draw.el line 158

 What it does first:
 1. Cycle Breaking: Since we have a DAG, no cycles need to be removed
    FUNCTION: `dag-draw-simple-break-cycles` (unused for DAGs)
    STATE: Graph structure remains in `dag-draw-graph-edges` list
    
 2. Hierarchical Ranking: Assigns each node a rank (layer) based on longest path from sources
    FUNCTION: `dag-draw-assign-ranks` 
    VARIABLES: Stores rank in `dag-draw-node-rank` field of each node struct
    STATE: Integer rank numbers (0, 1, 2, etc.) stored in node structs
    ADDITIONAL: `dag-draw-graph-max-rank` field tracks highest rank assigned
    
   - A gets rank 0 (source node)
   - B gets rank 1 (A→B)
   - C gets rank 2 (A→B→C)
   - D gets rank 2 (A→B→D, but A→D also exists, so max path length determines rank)

 Output: Each node has a rank number indicating its hierarchical level.
 STATE STORED: `(dag-draw-node-rank node)` contains integer rank for each node
 NORMALIZATION: `dag-draw-normalize-ranks` ensures minimum rank is 0

 Pass 2: Vertex Ordering (Crossing Reduction)
 FUNCTION: `dag-draw-order-vertices` in dag-draw-order-simple.el
 ENTRY POINT: Called from `dag-draw-layout-graph` in dag-draw.el line 159

 What it does next:
 1. Minimize Edge Crossings: Within each rank, order nodes to minimize edge crossings
    FUNCTION: `dag-draw--simple-crossing-reduction-with-convergence`
    ALGORITHM: Barycenter method with iterative improvement
    STATE: Integer order values stored in `dag-draw-node-order` field
    
 2. Barycenter Method: Calculate average positions of neighbors to determine optimal ordering
    FUNCTION: `dag-draw--calculate-barycenter`
    VARIABLES: Computes weighted average of neighbor positions
    
 3. Iterative Improvement: May sweep up and down ranks multiple times until convergence
    VARIABLES: `max-iterations` parameter, convergence detection
    STATE: Tracks crossing counts and convergence status

 For our example:
 - Rank 0: [A] (only one node)
 - Rank 1: [B] (only one node)
 - Rank 2: [C, D] or [D, C] (algorithm chooses based on crossing minimization)

 Output: Ordered list of nodes within each rank.
 STATE STORED: `(dag-draw-node-order node)` contains integer order within rank

 Pass 3: Coordinate Assignment
 FUNCTION: `dag-draw-position-nodes` in dag-draw-position.el
 ENTRY POINT: Called from `dag-draw-layout-graph` in dag-draw.el line 160

 What it does:
 1. Y-coordinates: Assign based on rank (rank × vertical spacing)
    CALCULATION: `y = rank * dag-draw-graph-rank-separation`
    STATE: Stored in `dag-draw-node-y-coord` field (floating point world coordinates)
    
 2. X-coordinates: Use network simplex algorithm to minimize edge lengths while respecting ordering
    FUNCTION: `dag-draw--build-auxiliary-graph` creates optimization problem
    ALGORITHM: Network simplex on auxiliary graph with separation constraints
    STATE: Stored in `dag-draw-node-x-coord` field (floating point world coordinates)
    AUXILIARY STATE: `dag-draw-graph-adjusted-positions` hash table stores collision-adjusted coordinates
    
 3. Node Sizing: Calculate actual node dimensions based on text content
    FUNCTIONS: `dag-draw--format-node-text-with-constraints`, `dag-draw--calculate-constrained-node-size`
    STATE: `dag-draw-node-x-size` and `dag-draw-node-y-size` fields (world coordinate units)
    
 4. Collision Detection: Ensure nodes don't overlap
    FUNCTION: `dag-draw--resolve-node-collision` in dag-draw-ascii-grid.el
    STATE: Updates `dag-draw-graph-adjusted-positions` hash table with format: id -> (x y width height)

 For our example:
 - A: (x₁, 0)
 - B: (x₂, rank_spacing)
 - C: (x₃, 2×rank_spacing)
 - D: (x₄, 2×rank_spacing)

 Output: Each node has final (x,y) coordinates and dimensions.
 STATE STORED: 
 - `(dag-draw-node-x-coord node)` - X coordinate in world units (floating point)
 - `(dag-draw-node-y-coord node)` - Y coordinate in world units (floating point)  
 - `(dag-draw-node-x-size node)` - Node width in world units
 - `(dag-draw-node-y-size node)` - Node height in world units
 - `(dag-draw-graph-adjusted-positions graph)` - Hash table with collision-adjusted coordinates

 Pass 4: Spline Generation and ASCII Conversion
 FUNCTION: `dag-draw-generate-splines` in dag-draw-splines.el
 ENTRY POINT: Called from `dag-draw-layout-graph` in dag-draw.el line 161
 ASCII CONVERSION: `dag-draw-render-ascii` in dag-draw-render.el

 What it does:
 1. Spline Creation: Generate smooth curves for each edge using control points
    FUNCTION: `dag-draw--create-downward-spline`, `dag-draw--create-upward-spline`, `dag-draw--create-flat-spline`
    ALGORITHM: GKNV Section 5.2 three-stage process: L-array → s-array → bboxes
    STATE: Bezier curve control points stored in `dag-draw-edge-spline-points` field
    COORDINATES: World coordinate system (floating point)
    
 2. Port Calculation: Determine where edges attach to node boundaries
    FUNCTION: `dag-draw--get-node-port` in dag-draw-ports.el
    STATE: Returns `dag-draw-point` structures with precise attachment coordinates
    SIDES: 'top, 'bottom, 'left, 'right determine port positions
    
 3. ASCII Grid Conversion: Convert world coordinates to character grid positions
    FUNCTION: `dag-draw--world-to-grid-coord` in dag-draw-ascii-grid.el
    SCALE FACTOR: `dag-draw-ascii-coordinate-scale` = 0.15 (converts GKNV world → ASCII grid)
    COORDINATE TRANSFORMATION: grid_coord = round((world_coord - min_coord) * 0.15)
    STATE: Integer grid coordinates suitable for character array indexing
    CONTEXT: `dag-draw--create-ascii-coordinate-context` normalizes coordinates to eliminate negatives
    
 4. Character Rendering: Draw nodes as boxes, edges as lines, arrows at endpoints
    FUNCTIONS: 
    - `dag-draw--draw-node-text-and-border` - Node boxes with ┌─┐│└┘ characters
    - `dag-draw--draw-edges-gknv-compliant` - Edge lines with ─│ characters  
    - `dag-draw--draw-arrow` - Directional arrows ▲▼◀▶
    - `dag-draw--post-process-junction-characters` - Junction characters ┼├┤┬┴
    STATE: 2D character grid stored as vector of vectors: `(aref (aref grid y) x)`
    OCCUPANCY MAP: `dag-draw--global-occupancy-map` prevents boundary violations (GKNV Section 5.2)

 For ASCII specifically:
 - Nodes become text boxes with border characters (┌─┐│└┘)
 - Edges become line characters (─│) with junctions (┼├┤┬┴) 
 - Arrows become directional characters (▲▼◀▶)
 FINAL OUTPUT: String representation via `dag-draw--ascii-grid-to-string`

 Information Flow and Iteration Requirements

 What Information Triggers Backtracking?

 !!! IMPLEMENTATION DISCREPANCY: The elisp implementation does NOT implement backtracking between passes.
 The algorithm executes passes 1-4 sequentially without iteration or refinement loops.

 1. Coordinate Conflicts in Pass 3:
   - If nodes overlap after coordinate assignment
   - If edges become too long or create poor aesthetics  
   - Triggers: Return to Pass 2 to try different vertex ordering
   !!! NOT IMPLEMENTED: No backtracking from Pass 3 to Pass 2

 2. Spline Routing Problems in Pass 4:
   - If edges cross through node interiors (violates Section 5.2)
   - If too many edge crossings create visual confusion
   - Triggers: Return to Pass 2 or 3 for better positioning
   !!! PARTIAL IMPLEMENTATION: Section 5.2 boundary clipping is implemented via occupancy maps,
   but no backtracking occurs - violations are prevented rather than triggering re-layout

 3. ASCII Grid Limitations:
   - If coordinate scaling produces overlapping characters
   - If node text doesn't fit in allocated space
   - Triggers: Adjust scaling parameters or return to Pass 3
   !!! NOT IMPLEMENTED: No automatic parameter adjustment or backtracking

 Information Required at Each Step

 Pass 1 Requirements:
 - Graph structure (nodes and edges)
   VARIABLES: `dag-draw-graph-nodes` (hash table), `dag-draw-graph-edges` (list)
 - No additional information needed

 Pass 2 Requirements:
 - Node ranks from Pass 1
   INPUT: `(dag-draw-node-rank node)` from each node
 - Edge connectivity  
   INPUT: `dag-draw-graph-edges` list with `dag-draw-edge-from-node` and `dag-draw-edge-to-node`
 - May need node size estimates for better ordering
   !!! NOT USED: Node sizes are not considered during ordering phase

 Pass 3 Requirements:
 - Vertex ordering from Pass 2
   INPUT: `(dag-draw-node-order node)` from each node
 - Node ranks from Pass 1
   INPUT: `(dag-draw-node-rank node)` from each node
 - Actual node dimensions (text size)
   INPUT: `(dag-draw-node-x-size node)` and `(dag-draw-node-y-size node)`
 - Spacing parameters
   INPUT: `dag-draw-graph-node-separation` and `dag-draw-graph-rank-separation`

 Pass 4 Requirements:
 - Final coordinates from Pass 3
   INPUT: `(dag-draw-node-x-coord node)` and `(dag-draw-node-y-coord node)` in world coordinates
   ALSO: `(dag-draw-graph-adjusted-positions graph)` for collision-adjusted coordinates
 - Node dimensions
   INPUT: `(dag-draw-node-x-size node)` and `(dag-draw-node-y-size node)` 
 - ASCII grid parameters (scale factors, character spacing)
   VARIABLES: `dag-draw-ascii-coordinate-scale` = 0.15
 - Spline generation parameters
   VARIABLES: Bezier curve control point calculations, port distribution settings

 State Management: Global vs Passed

 The GKNV algorithm uses hybrid state management:

 Global State (in implementation):

 - Graph structure: Nodes and edges remain constant
   STORAGE: `dag-draw-graph` struct contains `nodes` hash table and `edges` list
   PERSISTENCE: Graph object passed through all functions, mutations modify in-place

 - Algorithm parameters: Spacing, scaling factors, iteration limits  
   VARIABLES: `dag-draw-graph-node-separation`, `dag-draw-graph-rank-separation`
   ASCII SCALING: `dag-draw-ascii-coordinate-scale` global customization variable

 - ASCII grid: Shared coordinate system and character grid
   STORAGE: 2D vector array created in `dag-draw-render-ascii`
   OCCUPANCY: `dag-draw--global-occupancy-map` global variable for boundary detection

 Passed Information:

 - Rank assignments: Pass 1 → Pass 2
   MECHANISM: Stored in node struct fields, accessed by subsequent passes
   
 - Vertex ordering: Pass 2 → Pass 3
   MECHANISM: Stored in `dag-draw-node-order` field, read during positioning
   
 - Coordinates: Pass 3 → Pass 4  
   MECHANISM: Stored in `dag-draw-node-x-coord` and `dag-draw-node-y-coord` fields
   ALSO: `dag-draw-graph-adjusted-positions` hash table for collision-adjusted coordinates
   
 - Collision adjustments: May flow backward when conflicts detected
   !!! NOT IMPLEMENTED: No backward flow - adjustments are made during Pass 3 only

 Example Flow for A→B, B→C, B→D, A→D:

 1. Pass 1: A(rank=0), B(rank=1), C(rank=2), D(rank=2)
    RESULT: `(dag-draw-node-rank A) = 0`, `(dag-draw-node-rank B) = 1`, etc.
    
 2. Pass 2: Orders within ranks, e.g., rank 2: [C, D]  
    RESULT: `(dag-draw-node-order C) = 0`, `(dag-draw-node-order D) = 1` within rank 2
    
 3. Pass 3: Assigns coordinates, detects B needs to be centered between C and D
    RESULT: World coordinates in `dag-draw-node-x-coord` and `dag-draw-node-y-coord`
    COLLISION DETECTION: Updates `dag-draw-graph-adjusted-positions` if needed
    
 4. Pass 4:
   - Creates splines: A→B (straight down), B→C (diagonal), B→D (diagonal), A→D (long diagonal)
     RESULT: Bezier curves stored in `dag-draw-edge-spline-points` for each edge
   - Converts to ASCII: A and B become text boxes, edges become line characters
     COORDINATE CONVERSION: World coordinates → ASCII grid via `dag-draw--world-to-grid-coord`
     GRID COORDINATES: Integer positions suitable for character array indexing
   - Applies Section 5.2 boundary clipping to ensure edges terminate at node borders
     IMPLEMENTATION: Occupancy map prevents character placement in node interiors

 The algorithm is iterative and adaptive - later passes can trigger refinements in earlier passes when conflicts are detected, ensuring the final output respects both aesthetic and technical constraints (like GKNV Section 5.2 boundary clipping for ASCII rendering).

 !!! IMPLEMENTATION REALITY: The elisp implementation is LINEAR, not iterative. 
 Passes execute sequentially without backtracking. Conflicts are resolved through:
 - Collision detection and adjustment during Pass 3
 - Boundary violation prevention via occupancy maps during ASCII rendering
 - No automatic parameter adjustment or re-layout when problems occur