\input texinfo    @c -*- texinfo -*-
@c %**start of header
@setfilename ../dag-draw.info
@settitle Dag Draw User Manual
@documentencoding UTF-8
@documentlanguage en
@c %**end of header

@copying
noindent
SPDX-License-Identifier: GPL-3.0

Copyright (C) 2023-2025

You can redistribute this document and/or modify it under the terms
of the GNU General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any
later version.

This document is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE@.  See the GNU
General Public License for more details.
@end copying

@dircategory Emacs
@direntry
* Dag Draw: (dag-draw). Draw directed acyclic graphs that don't suck.
@end direntry

@finalout
@titlepage
@title Dag Draw User Manual
@subtitle for version 0.1.0
@author Generated by Claude
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents

@ifnottex
@node Top
@top Dag Draw User Manual

Dag Draw is an Emacs Lisp library for drawing directed acyclic graphs (DAGs) using the industry-standard GKNV algorithm from Graphviz.

@noindent
This manual is for Dag Draw version 0.1.0
@end ifnottex

@menu
* Introduction::                 What is dag-draw and why should you care?
* Getting Started::              Your first graph in 30 seconds
* Tutorial From Basics to Advanced:: Learn to use dag-draw effectively
* Reference::                    Complete API documentation
* Troubleshooting::              Common problems and solutions
* Advanced Topics::              Advanced usage and customization
* Contributing::                 How to contribute to dag-draw
* Index::                        Complete index
* Function Index::
* Variable Index::

@detailmenu
--- The Detailed Node Listing ---

Introduction

* What is dag-draw?::
* Why use dag-draw?::
* What's a DAG@?::
* How does it work?::

Getting Started

* Installation::                 Get dag-draw into your Emacs
* Your First Graph (The Black Triangle):: A working example in 30 seconds
* Understanding What Just Happened::
* A Slightly More Complex Example::

Installation

* Dependencies::
* From Source::
* Using package.el: Using packageel. 


Understanding What Just Happened

* Step 1 Create a Graph::
* Step 2 Add Nodes::
* Step 3 Connect with Edges::
* Step 4 Layout and Render::


Tutorial: From Basics to Advanced

* Working with Nodes::           Creating and customizing nodes
* Working with Edges::           Creating and customizing edges
* Layout The Magic Step::        Understanding layout and customization
* Rendering From Coordinates to Pictures:: Producing visual output
* Practical Examples::           Real-world use cases

Working with Nodes

* Basic Node Creation::
* Node Labels::
* Node Attributes::
* Visual Properties::
* Retrieving Nodes::


Working with Edges

* Basic Edge Creation::
* Multiple Edges::
* Edge Weights::
* Edge Labels::
* Edge Constraints::


Layout: The Magic Step

* Basic Layout::
* What Layout Does::
* Customizing Spacing::
* ASCII vs High-Resolution Layout::
* Rank Constraints::


Rendering: From Coordinates to Pictures

* ASCII Rendering::
* SVG Rendering::
* DOT Rendering::
* Choosing the Right Format::


Practical Examples

* Example 1 Course Prerequisites::
* Example 2 Build Dependencies::
* Example 3 Project Task Dependencies::


Reference

* Graph Functions::              Creating and manipulating graphs
* Node Functions::               Working with nodes
* Edge Functions::               Working with edges
* Rendering Functions::          Producing visual output
* Configuration Variables::      Customization options
* Graph Structure Accessors::    Direct graph structure access
* Data Structure Details::       Understanding the internal structures

Graph Functions

* dag-draw-create-graph::
* dag-draw-layout-graph::


Node Functions

* dag-draw-add-node::
* dag-draw-get-node::
* Node Accessors::


Edge Functions

* dag-draw-add-edge::
* dag-draw-get-edges::
* Edge Accessors::


Rendering Functions

* dag-draw-render-graph::


Configuration Variables

* dag-draw-default-node-separation::
* dag-draw-default-rank-separation::
* dag-draw-ascii-node-separation::
* dag-draw-ascii-rank-separation::
* dag-draw-default-output-format::


Graph Structure Accessors

* dag-draw-graph-nodes::
* dag-draw-graph-edges::
* dag-draw-graph-node-separation::
* dag-draw-graph-rank-separation::
* dag-draw-graph-coordinate-mode::


Data Structure Details

* Node Structure::
* Edge Structure::
* Graph Structure::


Troubleshooting

* Graph has cycles::
* Node not found::
* Nodes overlap in ASCII output::
* Graph looks cramped::
* Graph looks too spread out::
* Must call layout before rendering::
* ASCII output shows broken characters::
* SVG doesn't display in Emacs::
* Performance is slow for large graphs::
* Edges cross when they shouldn't::

Advanced Topics

* Understanding the GKNV Algorithm::
* Custom Renderers::
* Integration Examples::
* Performance Optimization::
* Coordinate Systems::

Understanding the GKNV Algorithm

* The Four Passes::
* Why This Algorithm?::


Custom Renderers

* Renderer Interface::
* Accessing Layout Information::
* Example Simple Text Renderer::


Integration Examples

* With Org Mode::
* With Project Management::


Performance Optimization

* Caching Layouts::
* Incremental Updates::


Coordinate Systems

* ASCII Mode (Default)::
* High-Resolution Mode::
* When to Use Which::


Contributing

* Development Setup::
* Testing::
* Code Style::
* Pull Requests::
* Reporting Bugs::

@end detailmenu
@end menu

@node Introduction
@chapter Introduction

@menu
* What is dag-draw?::
* Why use dag-draw?::
* What's a DAG@?::
* How does it work?::
@end menu

@node What is dag-draw?
@section What is dag-draw?

Ever tried to draw a flowchart? You spend hours moving boxes around, trying to untangle crossing lines, and the result still looks like spaghetti.

@strong{dag-draw.el} solves this problem. You focus on the @strong{structure} (what connects to what), and it handles the @strong{layout} (where everything goes).

Instead of manually positioning boxes and arrows, you write:

@lisp
;; You write this:
(setq my-graph (dag-draw-create-graph))
(dag-draw-add-node my-graph 'design "Design")
(dag-draw-add-node my-graph 'build "Build")
(dag-draw-add-node my-graph 'test "Test")
(dag-draw-add-edge my-graph 'design 'build)
(dag-draw-add-edge my-graph 'design 'test)
(dag-draw-add-edge my-graph 'build 'test)
(dag-draw-layout-graph my-graph)
(dag-draw-render-graph my-graph 'ascii)
@end lisp

And it produces:

@example
┌──────┐
│Design│
└───┬──┘
    │
    ├────────────────┐
    │                │
    ▼                ▼
┌───────┐        ┌──────┐
│Build  │───────▶│Test  │
└───────┘        └──────┘
@end example

@strong{No manual positioning. No tangled arrows. Just clean, hierarchical layouts.}

@node Why use dag-draw?
@section Why use dag-draw?

@strong{For end users:}
@itemize
@item
@strong{Save time}: No more manual layout adjustments
@item
@strong{Professional results}: Uses the same algorithm as Graphviz
@item
@strong{Multiple formats}: Output to ASCII (terminal/docs) or SVG (web/presentations)
@item
@strong{Pure Elisp}: No external dependencies, works anywhere Emacs runs
@end itemize

@strong{Common use cases:}
@itemize
@item
Project dependency visualization (Task A must finish before B and C)
@item
Course prerequisite charts (You need Calc I before Calc II)
@item
File dependency graphs (main.c includes utils.h)
@item
Workflow diagrams (Design → Build → Test → Deploy)
@item
Any hierarchical relationship that forms a DAG
@end itemize

@node What's a DAG@?
@section What's a DAG@?

A @strong{Directed Acyclic Graph} is:
@itemize
@item
@strong{Directed}: Arrows point in specific directions (A → B means "A comes before B")
@item
@strong{Acyclic}: No loops (you can't follow arrows and end up back where you started)
@item
@strong{Graph}: Nodes (boxes) connected by edges (arrows)
@end itemize

Think of a family tree, or a course prerequisite chart. These are DAGs because:
@itemize
@item
Relationships have direction (parent → child, prerequisite → course)
@item
No cycles exist (you can't be your own ancestor, a course can't require itself)
@end itemize

Valid DAG:
@example
A → B → C
@end example

Invalid (has a cycle):
@example
A → B → C → A  (cycle!)
@end example

@node How does it work?
@section How does it work?

dag-draw implements the @strong{GKNV algorithm} from a seminal 1993 paper:

@quotation
Gansner, E@. R., Koutsofios, E., North, S@. C., & Vo, K@. P@. (1993).
"A Technique for Drawing Directed Graphs."
IEEE Transactions on Software Engineering, 19(3), 214-230.

@end quotation

This is the same algorithm used by @strong{Graphviz}, the industry standard for graph layout. It has been cited thousands of times and is optimal for hierarchical graphs.

The algorithm runs in four automatic passes:
@enumerate
@item
@strong{Ranking}: Assigns vertical levels (what goes on top, middle, bottom)
@item
@strong{Ordering}: Arranges nodes horizontally to minimize crossing arrows
@item
@strong{Positioning}: Calculates exact X,Y coordinates
@item
@strong{Splines}: Draws smooth curves for edges
@end enumerate

You don't need to understand the algorithm to use dag-draw. Just call @code{dag-draw-layout-graph} and it handles everything.

@node Getting Started
@chapter Getting Started

This section will teach you to create and render your first graph. By the end, you'll have a working example you can modify.

@menu
* Installation::                 Get dag-draw into your Emacs
* Your First Graph (The Black Triangle):: A working example in 30 seconds
* Understanding What Just Happened::
* A Slightly More Complex Example::
@end menu

@node Installation
@section Installation

@menu
* Dependencies::
* From Source::
* Using package.el: Using packageel. 
@end menu

@node Dependencies
@subsection Dependencies

dag-draw requires:
@itemize
@item
Emacs 26.1 or higher
@item
@code{dash} library (list manipulation)
@item
@code{ht} library (hash tables)
@end itemize

@node From Source
@subsection From Source

Clone the repository and add to your load path:

@example
git clone https://github.com/example/dag-draw.el.git
@end example

Add to your Emacs configuration:

@lisp
(add-to-list 'load-path "~/path/to/dag-draw.el")
(require 'dag-draw)
@end lisp

@node Using packageel
@subsection Using package.el

When released on MELPA:

@lisp
M-x package-install RET dag-draw RET
@end lisp

@node Your First Graph (The Black Triangle)
@section Your First Graph (The Black Triangle)

Let's create a simple three-step workflow. Type this into your @code{*scratch*} buffer and evaluate with @code{C-x C-e}:

@lisp
(require 'dag-draw)

;; Step 1: Create a graph
(setq my-graph (dag-draw-create-graph))

;; Step 2: Add nodes
(dag-draw-add-node my-graph 'start "Start Here")
(dag-draw-add-node my-graph 'middle "Do Work")
(dag-draw-add-node my-graph 'done "Finish")

;; Step 3: Connect them with edges
(dag-draw-add-edge my-graph 'start 'middle)
(dag-draw-add-edge my-graph 'middle 'done)

;; Step 4: Layout and render
(dag-draw-layout-graph my-graph)
(dag-draw-render-graph my-graph 'ascii)
@end lisp

You should see:

@example
┌────────────┐
│Start Here  │
└──────┬─────┘
       │
       ▼
┌────────────┐
│Do Work     │
└──────┬─────┘
       │
       ▼
┌────────────┐
│Finish      │
└────────────┘
@end example

@strong{Congratulations!} You just created your first automatically-laid-out graph.

@node Understanding What Just Happened
@section Understanding What Just Happened

Let's break down each step:

@menu
* Step 1 Create a Graph::
* Step 2 Add Nodes::
* Step 3 Connect with Edges::
* Step 4 Layout and Render::
@end menu

@node Step 1 Create a Graph
@subsection Step 1: Create a Graph

@lisp
(setq my-graph (dag-draw-create-graph))
@end lisp

This creates an empty graph structure. Think of it as a blank canvas.

@node Step 2 Add Nodes
@subsection Step 2: Add Nodes

@lisp
(dag-draw-add-node my-graph 'start "Start Here")
@end lisp

@itemize
@item
@strong{First argument}: The graph to add to
@item
@strong{Second argument}: A unique ID (can be symbol or string)
@item
@strong{Third argument}: The display label (what users see)
@end itemize

The ID is for your code to reference. The label is what appears in the rendered output.

@node Step 3 Connect with Edges
@subsection Step 3: Connect with Edges

@lisp
(dag-draw-add-edge my-graph 'start 'middle)
@end lisp

This creates a directed edge from @code{start} to @code{middle}. The arrow points from the first ID to the second.

@node Step 4 Layout and Render
@subsection Step 4: Layout and Render

@lisp
(dag-draw-layout-graph my-graph)
(dag-draw-render-graph my-graph 'ascii)
@end lisp

@itemize
@item
@code{dag-draw-layout-graph} runs the GKNV algorithm (assigns positions)
@item
@code{dag-draw-render-graph} converts positions to visual output
@end itemize

You must layout before rendering. Layout calculates where everything goes; render draws it.

@node A Slightly More Complex Example
@section A Slightly More Complex Example

Let's add some branching to make it interesting:

@lisp
(setq project-graph (dag-draw-create-graph))

;; Add nodes for a project workflow
(dag-draw-add-node project-graph 'plan "Planning")
(dag-draw-add-node project-graph 'design "Design")
(dag-draw-add-node project-graph 'code "Write Code")
(dag-draw-add-node project-graph 'test "Testing")
(dag-draw-add-node project-graph 'docs "Documentation")
(dag-draw-add-node project-graph 'deploy "Deploy")

;; Create dependencies
(dag-draw-add-edge project-graph 'plan 'design)
(dag-draw-add-edge project-graph 'plan 'docs)
(dag-draw-add-edge project-graph 'design 'code)
(dag-draw-add-edge project-graph 'code 'test)
(dag-draw-add-edge project-graph 'test 'deploy)
(dag-draw-add-edge project-graph 'docs 'deploy)

;; Layout and render
(dag-draw-layout-graph project-graph)
(dag-draw-render-graph project-graph 'ascii)
@end lisp

Output:

@example
     ┌─────────┐
     │Planning │
     └────┬────┘
          │
     ┌────┴──────────────┐
     │                   │
     ▼                   ▼
┌────────┐         ┌──────────────┐
│Design  │         │Documentation │
└────┬───┘         └──────┬───────┘
     │                    │
     ▼                    │
┌──────────────┐          │
│Write Code    │          │
└──────┬───────┘          │
       │                  │
       ▼                  │
┌────────┐                │
│Testing │                │
└────┬───┘                │
     │                    │
     ├────────────────────┘
     │
     ▼
┌────────┐
│Deploy  │
└────────┘
@end example

Notice how dag-draw automatically:
@itemize
@item
Positioned "Planning" at the top (no dependencies)
@item
Arranged "Design" and "Documentation" in parallel (both depend only on Planning)
@item
Minimized crossing lines
@item
Made edges merge cleanly at "Deploy"
@end itemize

@strong{You specified structure. dag-draw handled layout.}

@node Tutorial From Basics to Advanced
@chapter Tutorial: From Basics to Advanced

This section teaches you everything you need to use dag-draw effectively, from simple graphs to advanced customization.

@menu
* Working with Nodes::           Creating and customizing nodes
* Working with Edges::           Creating and customizing edges
* Layout The Magic Step::        Understanding layout and customization
* Rendering From Coordinates to Pictures:: Producing visual output
* Practical Examples::           Real-world use cases
@end menu

@node Working with Nodes
@section Working with Nodes

@menu
* Basic Node Creation::
* Node Labels::
* Node Attributes::
* Visual Properties::
* Retrieving Nodes::
@end menu

@node Basic Node Creation
@subsection Basic Node Creation

The simplest form uses just an ID and label:

@lisp
(dag-draw-add-node graph 'my-node "Display Label")
@end lisp

The node ID must be unique within the graph. Use symbols or strings:

@lisp
;; Both work
(dag-draw-add-node graph 'node1 "First Node")
(dag-draw-add-node graph "node2" "Second Node")
@end lisp

@strong{Convention}: Use symbols for IDs (easier to type, no quotes needed in most places).

@node Node Labels
@subsection Node Labels

Labels can be any string. They're what users see in the rendered output:

@lisp
;; Short labels
(dag-draw-add-node graph 'start "Start")

;; Long labels (will be auto-wrapped)
(dag-draw-add-node graph 'analyze "Analyze Requirements and Create Specifications")

;; Labels with special characters
(dag-draw-add-node graph 'build "Build (v2.0)")
@end lisp

@strong{Note}: Long labels are automatically wrapped to fit within node boundaries. The default constraint is 2 rows × 20 characters maximum.

@node Node Attributes
@subsection Node Attributes

You can attach custom attributes to nodes for rendering hints:

@lisp
(require 'ht)  ; Hash table library

;; Create attributes hash
(setq node-attrs (ht ("color" "red")
                     ("shape" "diamond")
                     ("style" "bold")))

(dag-draw-add-node graph 'critical "Critical Task" node-attrs)
@end lisp

Attributes are used by renderers (especially SVG) for styling. ASCII rendering ignores most attributes but uses them for semantic meaning in your code.

@node Visual Properties
@subsection Visual Properties

Visual properties let you style individual nodes to show status, priority, or categories.

@menu
* Quick Example::
* ASCII Visual Properties::
* SVG Visual Properties::
* Multi-Format Properties::
* Common Patterns::
@end menu

@node Quick Example
@unnumberedsubsubsec Quick Example

Show task completion with markers:

@lisp
(require 'ht)

;; Completed task with checkmark
(dag-draw-add-node graph 'done "Research"
  (ht (:ascii-marker "✓ ")))

;; In-progress task with double border
(dag-draw-add-node graph 'active "Implementation"
  (ht (:ascii-highlight t)
      (:ascii-marker "→ ")))

;; SVG with custom colors
(dag-draw-add-node graph 'critical "Fix Bug"
  (ht (:svg-fill "#ff4444")
      (:svg-stroke "#cc0000")
      (:svg-stroke-width 3)))
@end lisp

@node ASCII Visual Properties
@unnumberedsubsubsec ASCII Visual Properties

@strong{ASCII Markers}: Prepend text to labels

@lisp
(dag-draw-add-node graph 'task1 "Done" (ht (:ascii-marker "✓ ")))
(dag-draw-add-node graph 'task2 "Current" (ht (:ascii-marker "→ ")))
(dag-draw-add-node graph 'task3 "Blocked" (ht (:ascii-marker "✗ ")))
@end lisp

Renders as:
@example
┌──────────┐
│✓ Done    │
└──────────┘
@end example

@strong{ASCII Highlighting}: Double-line borders

@lisp
(dag-draw-add-node graph 'important "Critical"
  (ht (:ascii-highlight t)))
@end lisp

Renders with double borders (@code{╔═╗}) instead of single (@code{┌─┐}):
@example
╔══════════╗
║Critical  ║
╚══════════╝
@end example

@node SVG Visual Properties
@unnumberedsubsubsec SVG Visual Properties

@strong{Fill Color}: Background color

@lisp
(dag-draw-add-node graph 'success "Passed"
  (ht (:svg-fill "#90ee90")))  ; Light green
@end lisp

@strong{Stroke Color and Width}: Border styling

@lisp
(dag-draw-add-node graph 'warning "Alert"
  (ht (:svg-fill "#ffd700")        ; Gold fill
      (:svg-stroke "#ff8c00")      ; Orange border
      (:svg-stroke-width 2)))      ; Thicker border
@end lisp

@node Multi-Format Properties
@unnumberedsubsubsec Multi-Format Properties

Combine ASCII and SVG properties for graphs rendered in both formats:

@lisp
(dag-draw-add-node graph 'done "Complete"
  (ht (:ascii-marker "✓ ")
      (:ascii-highlight nil)
      (:svg-fill "#90ee90")
      (:svg-stroke "#228b22")
      (:svg-stroke-width 2)))
@end lisp

ASCII output: @code{✓ Complete} with checkmark

SVG output: Green background, dark green border

@node Common Patterns
@unnumberedsubsubsec Common Patterns

@strong{Traffic Light Status}:
@lisp
;; Good
(ht (:svg-fill "#90ee90"))

;; Warning
(ht (:svg-fill "#ffd700") (:svg-stroke "#ff8c00"))

;; Error
(ht (:svg-fill "#ff4444") (:svg-stroke "#cc0000") (:svg-stroke-width 3))
@end lisp

@strong{Progress Markers}:
@lisp
(ht (:ascii-marker "✓ "))  ; Completed
(ht (:ascii-marker "→ "))  ; Current
(ht (:ascii-marker "○ "))  ; Future
@end lisp

@node Retrieving Nodes
@subsection Retrieving Nodes

After adding nodes, you can retrieve them:

@lisp
(setq node (dag-draw-get-node graph 'my-node))

;; Access node properties
(dag-draw-node-id node)       ; => 'my-node
(dag-draw-node-label node)    ; => "Display Label"
(dag-draw-node-x-coord node)  ; => nil (before layout) or number (after)
(dag-draw-node-y-coord node)  ; => nil (before layout) or number (after)
(dag-draw-node-rank node)     ; => nil (before layout) or rank number (after)
@end lisp

@strong{Coordinate properties are nil until you call @code{dag-draw-layout-graph}.}

@node Working with Edges
@section Working with Edges

@menu
* Basic Edge Creation::
* Multiple Edges::
* Edge Weights::
* Edge Labels::
* Edge Constraints::
@end menu

@node Basic Edge Creation
@subsection Basic Edge Creation

Edges connect two nodes by their IDs:

@lisp
(dag-draw-add-edge graph 'node-a 'node-b)
@end lisp

This creates a directed edge from @code{node-a} to @code{node-b}. The arrow points from first to second.

@strong{Direction matters}: @code{(dag-draw-add-edge graph 'a 'b)} is NOT the same as @code{(dag-draw-add-edge graph 'b 'a)}.

@node Multiple Edges
@subsection Multiple Edges

You can add multiple edges from the same node:

@lisp
;; A depends on both B and C
(dag-draw-add-edge graph 'b 'a)
(dag-draw-add-edge graph 'c 'a)

;; D depends on A
(dag-draw-add-edge graph 'a 'd)
@end lisp

This creates a diamond pattern:

@example
┌─┐  ┌─┐
│B│  │C│
└┬┘  └┬┘
 │    │
 └─┬──┘
   ▼
  ┌─┐
  │A│
  └┬┘
   │
   ▼
  ┌─┐
  │D│
  └─┘
@end example

@node Edge Weights
@subsection Edge Weights

Weights influence the layout algorithm (higher weights pull nodes closer):

@lisp
;; High-priority dependency (pulls nodes close)
(dag-draw-add-edge graph 'a 'b (ht ("weight" 10)))

;; Low-priority dependency (allows more distance)
(dag-draw-add-edge graph 'a 'c (ht ("weight" 1)))
@end lisp

@strong{Default weight is 1}. Higher weights (5-10) make the algorithm try harder to keep nodes close vertically.

@node Edge Labels
@subsection Edge Labels

Edges can have labels (useful for documenting relationships):

@lisp
(setq edge-attrs (ht ("label" "requires")))
(dag-draw-add-edge graph 'design 'coding edge-attrs)
@end lisp

@strong{Note}: Edge label rendering support varies by format. SVG supports them well; ASCII may not display them.

@node Edge Constraints
@subsection Edge Constraints

Minimum length constraints force vertical separation:

@lisp
;; Force at least 2 ranks between nodes
(setq edge-attrs (ht ("min-length" 2)))
(dag-draw-add-edge graph 'top 'bottom edge-attrs)
@end lisp

Use this when you need visual separation between certain nodes.

@node Layout The Magic Step
@section Layout: The Magic Step

@menu
* Basic Layout::
* What Layout Does::
* Customizing Spacing::
* ASCII vs High-Resolution Layout::
* Rank Constraints::
@end menu

@node Basic Layout
@subsection Basic Layout

Layout is simple: just call the function.

@lisp
(dag-draw-layout-graph my-graph)
@end lisp

This runs the four-pass GKNV algorithm and assigns coordinates to all nodes and edges.

@strong{You must layout before rendering.} Rendering requires coordinates that layout provides.

@node What Layout Does
@subsection What Layout Does

When you call @code{dag-draw-layout-graph}, four things happen automatically:

@strong{Pass 1: Ranking (Vertical Levels)}

Assigns each node to a vertical level (rank):

@example
Rank 0:  [A] [B]        (no dependencies)
Rank 1:  [C] [D]        (depend on rank 0)
Rank 2:  [E]            (depends on rank 1)
@end example

Nodes with no incoming edges go at the top. Each subsequent rank depends on previous ranks.

@strong{Pass 2: Ordering (Horizontal Arrangement)}

Within each rank, arranges nodes horizontally to minimize crossing arrows.

The algorithm tries thousands of arrangements to find one with few crossings. This is the hardest computational problem in graph layout.

@strong{Pass 3: Positioning (Exact Coordinates)}

Calculates precise X,Y coordinates that:
@itemize
@item
Respect the ordering from Pass 2
@item
Keep minimum separation between nodes
@item
Align connected nodes nicely
@end itemize

@strong{Pass 4: Splines (Smooth Edges)}

Generates Bézier curve control points for edges that:
@itemize
@item
Route smoothly from source to destination
@item
Avoid overlapping nodes
@item
Create professional-looking curves
@end itemize

@node Customizing Spacing
@subsection Customizing Spacing

Control how much space appears between elements:

@lisp
;; Create graph with custom spacing
(setq my-graph (dag-draw-create-graph))

;; Set spacing before adding nodes
(setf (dag-draw-graph-node-separation my-graph) 30)  ; horizontal space
(setf (dag-draw-graph-rank-separation my-graph) 50)  ; vertical space

;; Add nodes and edges...
;; Then layout
(dag-draw-layout-graph my-graph)
@end lisp

@strong{Default values}:
@itemize
@item
Node separation: 20 units
@item
Rank separation: 25 units
@end itemize

@strong{Increase these values} if your graphs look cramped. @strong{Decrease them} for more compact output.

@node ASCII vs High-Resolution Layout
@subsection ASCII vs High-Resolution Layout

dag-draw supports two coordinate modes:

@lisp
;; ASCII mode (default, optimized for terminal output)
(setf (dag-draw-graph-coordinate-mode my-graph) 'ascii)

;; High-resolution mode (for SVG/detailed graphics)
(setf (dag-draw-graph-coordinate-mode my-graph) 'high-res)
@end lisp

@strong{ASCII mode} uses smaller separation values appropriate for character grids. @strong{High-res mode} uses the standard GKNV algorithm spacing.

@strong{Recommendation}: Use default (ASCII) unless you're only generating SVG output.

@node Rank Constraints
@subsection Rank Constraints

Sometimes you want to force certain nodes onto the same level:

@lisp
;; Force nodes 'a and 'b onto the same rank
(setf (dag-draw-graph-rank-sets my-graph)
      '(('a 'b)))
@end lisp

This is advanced usage. Most graphs don't need rank constraints.

@node Rendering From Coordinates to Pictures
@section Rendering: From Coordinates to Pictures

@menu
* ASCII Rendering::
* SVG Rendering::
* DOT Rendering::
* Choosing the Right Format::
@end menu

@node ASCII Rendering
@subsection ASCII Rendering

ASCII rendering produces box-drawing character output for terminals and plain text:

@lisp
(dag-draw-render-graph my-graph 'ascii)
@end lisp

Returns a string you can insert into buffers or print:

@lisp
(with-current-buffer (get-buffer-create "*Graph*")
  (erase-buffer)
  (insert (dag-draw-render-graph my-graph 'ascii))
  (goto-char (point-min))
  (pop-to-buffer (current-buffer)))
@end lisp

@strong{Best for}:
@itemize
@item
Quick previews
@item
README files
@item
Source code comments
@item
Email
@item
Terminal output
@end itemize

@strong{Requirements}:
@itemize
@item
Monospace font
@item
Unicode box-drawing character support
@end itemize

@node SVG Rendering
@subsection SVG Rendering

SVG rendering produces scalable vector graphics:

@lisp
(dag-draw-render-graph my-graph 'svg)
@end lisp

Returns an SVG string you can save to a file:

@lisp
(with-temp-file "~/my-graph.svg"
  (insert (dag-draw-render-graph my-graph 'svg)))
@end lisp

Or display in Emacs (if your Emacs build supports SVG):

@lisp
(with-current-buffer (get-buffer-create "*Graph SVG*")
  (erase-buffer)
  (insert-image (create-image
                 (dag-draw-render-graph my-graph 'svg)
                 'svg t))
  (pop-to-buffer (current-buffer)))
@end lisp

@strong{Best for}:
@itemize
@item
Documentation websites
@item
Presentations
@item
High-quality printouts
@item
Scalable diagrams
@end itemize

@strong{Advantages}:
@itemize
@item
Crisp at any zoom level
@item
Smooth curves
@item
Customizable styling
@item
Embeddable in HTML
@end itemize

@node DOT Rendering
@subsection DOT Rendering

DOT format is Graphviz's input language:

@lisp
(dag-draw-render-graph my-graph 'dot)
@end lisp

This outputs DOT language source that you can process with Graphviz tools.

@strong{Use this when}:
@itemize
@item
You need Graphviz-specific features
@item
You want to post-process with Graphviz
@item
You're debugging layout differences
@end itemize

@node Choosing the Right Format
@subsection Choosing the Right Format

@example
Use ASCII when:
  - Quick preview needed
  - Terminal/text-only environment
  - Including in code comments
  - Email or plain text documentation

Use SVG when:
  - Presentation quality matters
  - Web publishing
  - Need scalability
  - Want custom styling

Use DOT when:
  - Interfacing with Graphviz
  - Need Graphviz-specific features
  - Comparing layouts
@end example

@node Practical Examples
@section Practical Examples

@menu
* Example 1 Course Prerequisites::
* Example 2 Build Dependencies::
* Example 3 Project Task Dependencies::
@end menu

@node Example 1 Course Prerequisites
@subsection Example 1: Course Prerequisites

@lisp
(setq course-graph (dag-draw-create-graph))

;; First year courses
(dag-draw-add-node course-graph 'cs101 "Intro to CS")
(dag-draw-add-node course-graph 'math101 "Calculus I")
(dag-draw-add-node course-graph 'math102 "Calculus II")

;; Second year courses
(dag-draw-add-node course-graph 'cs201 "Data Structures")
(dag-draw-add-node course-graph 'cs202 "Algorithms")
(dag-draw-add-node course-graph 'math201 "Linear Algebra")

;; Third year courses
(dag-draw-add-node course-graph 'cs301 "Machine Learning")

;; Prerequisites
(dag-draw-add-edge course-graph 'cs101 'cs201)
(dag-draw-add-edge course-graph 'cs201 'cs202)
(dag-draw-add-edge course-graph 'math101 'math102)
(dag-draw-add-edge course-graph 'math102 'math201)
(dag-draw-add-edge course-graph 'cs202 'cs301)
(dag-draw-add-edge course-graph 'math201 'cs301)

(dag-draw-layout-graph course-graph)
(dag-draw-render-graph course-graph 'ascii)
@end lisp

@node Example 2 Build Dependencies
@subsection Example 2: Build Dependencies

@lisp
(setq build-graph (dag-draw-create-graph))

;; Source files
(dag-draw-add-node build-graph 'utils-h "utils.h")
(dag-draw-add-node build-graph 'utils-c "utils.c")
(dag-draw-add-node build-graph 'main-c "main.c")

;; Object files
(dag-draw-add-node build-graph 'utils-o "utils.o")
(dag-draw-add-node build-graph 'main-o "main.o")

;; Executable
(dag-draw-add-node build-graph 'program "program")

;; Dependencies
(dag-draw-add-edge build-graph 'utils-h 'utils-c)
(dag-draw-add-edge build-graph 'utils-c 'utils-o)
(dag-draw-add-edge build-graph 'utils-h 'main-c)
(dag-draw-add-edge build-graph 'main-c 'main-o)
(dag-draw-add-edge build-graph 'utils-o 'program)
(dag-draw-add-edge build-graph 'main-o 'program)

(dag-draw-layout-graph build-graph)
(dag-draw-render-graph build-graph 'ascii)
@end lisp

@node Example 3 Project Task Dependencies
@subsection Example 3: Project Task Dependencies

@lisp
(defun visualize-project-tasks ()
  "Create a visualization of project tasks."
  (let ((graph (dag-draw-create-graph)))

    ;; Define tasks
    (dag-draw-add-node graph 'requirements "Requirements")
    (dag-draw-add-node graph 'architecture "Architecture")
    (dag-draw-add-node graph 'ui-design "UI Design")
    (dag-draw-add-node graph 'backend "Backend Dev")
    (dag-draw-add-node graph 'frontend "Frontend Dev")
    (dag-draw-add-node graph 'integration "Integration")
    (dag-draw-add-node graph 'testing "Testing")
    (dag-draw-add-node graph 'deployment "Deployment")

    ;; Define dependencies
    (dag-draw-add-edge graph 'requirements 'architecture)
    (dag-draw-add-edge graph 'requirements 'ui-design)
    (dag-draw-add-edge graph 'architecture 'backend)
    (dag-draw-add-edge graph 'architecture 'frontend)
    (dag-draw-add-edge graph 'ui-design 'frontend)
    (dag-draw-add-edge graph 'backend 'integration)
    (dag-draw-add-edge graph 'frontend 'integration)
    (dag-draw-add-edge graph 'integration 'testing)
    (dag-draw-add-edge graph 'testing 'deployment)

    ;; Layout and display
    (dag-draw-layout-graph graph)

    ;; Insert into a buffer
    (with-current-buffer (get-buffer-create "*Project Tasks*")
      (erase-buffer)
      (insert "Project Task Dependencies\n")
      (insert "========================\n\n")
      (insert (dag-draw-render-graph graph 'ascii))
      (goto-char (point-min))
      (pop-to-buffer (current-buffer)))))
@end lisp

Call it with:

@lisp
(visualize-project-tasks)
@end lisp

@node Reference
@chapter Reference

This section documents every public function and variable in dag-draw.

@menu
* Graph Functions::              Creating and manipulating graphs
* Node Functions::               Working with nodes
* Edge Functions::               Working with edges
* Rendering Functions::          Producing visual output
* Configuration Variables::      Customization options
* Graph Structure Accessors::    Direct graph structure access
* Data Structure Details::       Understanding the internal structures
@end menu

@node Graph Functions
@section Graph Functions

@menu
* dag-draw-create-graph::
* dag-draw-layout-graph::
@end menu

@node dag-draw-create-graph
@subsection dag-draw-create-graph

@lisp
(dag-draw-create-graph &optional attributes)
@end lisp

Create a new empty directed graph.

@strong{Arguments}:
@itemize
@item
@code{attributes} (optional): Hash table of graph-level attributes
@end itemize

@strong{Returns}: A new @code{dag-draw-graph} structure

@strong{Example}:
@lisp
;; Basic graph
(setq g (dag-draw-create-graph))

;; Graph with attributes
(setq g (dag-draw-create-graph (ht ("name" "My Graph")
                                    ("type" "workflow"))))
@end lisp

@node dag-draw-layout-graph
@subsection dag-draw-layout-graph

@lisp
(dag-draw-layout-graph graph)
@end lisp

Run the GKNV layout algorithm on a graph.

This function modifies the graph in-place, assigning coordinates to nodes and generating spline points for edges.

@strong{Arguments}:
@itemize
@item
@code{graph}: A @code{dag-draw-graph} structure
@end itemize

@strong{Returns}: The modified graph (for chaining)

@strong{Side effects}: Sets coordinates on all nodes and spline points on all edges

@strong{Example}:
@lisp
(dag-draw-add-node g 'a "A")
(dag-draw-add-node g 'b "B")
(dag-draw-add-edge g 'a 'b)
(dag-draw-layout-graph g)  ; Now nodes have coordinates
@end lisp

@strong{Note}: You must call this before rendering.

@node Node Functions
@section Node Functions

@menu
* dag-draw-add-node::
* dag-draw-get-node::
* Node Accessors::
@end menu

@node dag-draw-add-node
@subsection dag-draw-add-node

@lisp
(dag-draw-add-node graph node-id &optional label attributes)
@end lisp

Add a node to a graph.

@strong{Arguments}:
@itemize
@item
@code{graph}: The graph to add to
@item
@code{node-id}: Unique identifier (symbol or string)
@item
@code{label} (optional): Display label (defaults to node-id as string)
@item
@code{attributes} (optional): Hash table of node attributes
@end itemize

@strong{Returns}: The created node structure

@strong{Example}:
@lisp
;; Minimal
(dag-draw-add-node graph 'my-node)

;; With label
(dag-draw-add-node graph 'task1 "First Task")

;; With attributes
(dag-draw-add-node graph 'critical "Critical"
                   (ht ("color" "red")
                       ("priority" "high")))
@end lisp

@strong{Note}: Node IDs must be unique within a graph. Adding a node with an existing ID replaces the old node.

@node dag-draw-get-node
@subsection dag-draw-get-node

@lisp
(dag-draw-get-node graph node-id)
@end lisp

Retrieve a node by ID@.

@strong{Arguments}:
@itemize
@item
@code{graph}: The graph to search
@item
@code{node-id}: The node's unique identifier
@end itemize

@strong{Returns}: The node structure, or @code{nil} if not found

@strong{Example}:
@lisp
(setq node (dag-draw-get-node graph 'my-node))
(when node
  (message "Label: %s" (dag-draw-node-label node)))
@end lisp

@node Node Accessors
@subsection Node Accessors

@menu
* dag-draw-node-id::
* dag-draw-node-label::
* dag-draw-node-x-coord::
* dag-draw-node-y-coord::
* dag-draw-node-rank::
* dag-draw-node-order::
* dag-draw-node-attributes::
* Visual Properties Attributes::
@end menu

@node dag-draw-node-id
@unnumberedsubsubsec dag-draw-node-id

@lisp
(dag-draw-node-id node)
@end lisp

Get the node's unique identifier.

@strong{Returns}: The node ID (symbol or string)

@node dag-draw-node-label
@unnumberedsubsubsec dag-draw-node-label

@lisp
(dag-draw-node-label node)
@end lisp

Get the node's display label.

@strong{Returns}: String label

@node dag-draw-node-x-coord
@unnumberedsubsubsec dag-draw-node-x-coord

@lisp
(dag-draw-node-x-coord node)
@end lisp

Get the node's X coordinate.

@strong{Returns}: Number (after layout), or @code{nil} (before layout)

@node dag-draw-node-y-coord
@unnumberedsubsubsec dag-draw-node-y-coord

@lisp
(dag-draw-node-y-coord node)
@end lisp

Get the node's Y coordinate.

@strong{Returns}: Number (after layout), or @code{nil} (before layout)

@node dag-draw-node-rank
@unnumberedsubsubsec dag-draw-node-rank

@lisp
(dag-draw-node-rank node)
@end lisp

Get the node's assigned rank (vertical level).

@strong{Returns}: Integer rank (after layout), or @code{nil} (before layout)

Rank 0 is the top level. Higher ranks are lower in the visual output.

@node dag-draw-node-order
@unnumberedsubsubsec dag-draw-node-order

@lisp
(dag-draw-node-order node)
@end lisp

Get the node's order within its rank.

@strong{Returns}: Integer order (after layout), or @code{nil} (before layout)

Order 0 is leftmost. Higher orders are further right.

@node dag-draw-node-attributes
@unnumberedsubsubsec dag-draw-node-attributes

@lisp
(dag-draw-node-attributes node)
@end lisp

Get the node's attribute hash table.

@strong{Returns}: Hash table (possibly empty)

@strong{Example}:
@lisp
(setq attrs (dag-draw-node-attributes node))
(ht-get attrs "color")  ; => "red"
@end lisp

@node Visual Properties Attributes
@unnumberedsubsubsec Visual Properties Attributes

Node attributes support visual styling through prefixed keywords:

@itemize
@item
@anchor{ASCII Visual Properties (1)}ASCII Visual Properties


@multitable {aaaaaaaaaaaaaaaaaa} {aaaaaaa} {aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa} {aaaaaaaaaaaaaa}
@headitem Attribute
@tab Type
@tab Description
@tab Example
@item @code{:ascii-highlight}
@tab boolean
@tab Render with double-line borders (╔═╗)
@tab @code{t}
@item @code{:ascii-marker}
@tab string
@tab Prepend marker to label
@tab @code{"✓ "}, @code{"→ "}
@end multitable

@item
@anchor{SVG Visual Properties (1)}SVG Visual Properties


@multitable {aaaaaaaaaaaaaaaaaaa} {aaaaaa} {aaaaaaaaaaaaaaaaaaaaaaaaa} {aaaaaaaaaaa}
@headitem Attribute
@tab Type
@tab Description
@tab Example
@item @code{:svg-fill}
@tab string
@tab Fill color (CSS)
@tab @code{"#ff5733"}
@item @code{:svg-stroke}
@tab string
@tab Border color (CSS)
@tab @code{"#0000ff"}
@item @code{:svg-stroke-width}
@tab number
@tab Border thickness (pixels)
@tab @code{2}, @code{3}
@end multitable

@strong{Example}:
@lisp
;; ASCII: Double border with checkmark
(dag-draw-add-node graph 'done "Task"
  (ht (:ascii-highlight t)
      (:ascii-marker "✓ ")))

;; SVG: Green background, dark green border
(dag-draw-add-node graph 'success "Build"
  (ht (:svg-fill "#90ee90")
      (:svg-stroke "#228b22")
      (:svg-stroke-width 2)))

;; Both formats
(dag-draw-add-node graph 'active "Current"
  (ht (:ascii-highlight t)
      (:ascii-marker "→ ")
      (:svg-fill "#ffd700")
      (:svg-stroke "#ff8c00")))
@end lisp

@strong{Notes}:
@itemize
@item
ASCII attributes only affect ASCII rendering
@item
SVG attributes only affect SVG rendering
@item
Combine both for multi-format support
@item
Invalid attributes are silently ignored
@end itemize
@end itemize

@node Edge Functions
@section Edge Functions

@menu
* dag-draw-add-edge::
* dag-draw-get-edges::
* Edge Accessors::
@end menu

@node dag-draw-add-edge
@subsection dag-draw-add-edge

@lisp
(dag-draw-add-edge graph from-id to-id &optional attributes)
@end lisp

Add a directed edge to a graph.

@strong{Arguments}:
@itemize
@item
@code{graph}: The graph to add to
@item
@code{from-id}: Source node ID
@item
@code{to-id}: Destination node ID
@item
@code{attributes} (optional): Hash table of edge attributes
@end itemize

@strong{Returns}: The created edge structure

@strong{Example}:
@lisp
;; Basic edge
(dag-draw-add-edge graph 'a 'b)

;; Edge with weight
(dag-draw-add-edge graph 'a 'c (ht ("weight" 5)))

;; Edge with label
(dag-draw-add-edge graph 'a 'd (ht ("label" "requires")))
@end lisp

@strong{Note}: Both nodes must exist in the graph before adding an edge.

@node dag-draw-get-edges
@subsection dag-draw-get-edges

@lisp
(dag-draw-get-edges graph)
@end lisp

Get all edges in a graph.

@strong{Arguments}:
@itemize
@item
@code{graph}: The graph
@end itemize

@strong{Returns}: List of edge structures

@strong{Example}:
@lisp
(dolist (edge (dag-draw-get-edges graph))
  (message "Edge: %s -> %s"
           (dag-draw-edge-from-node edge)
           (dag-draw-edge-to-node edge)))
@end lisp

@node Edge Accessors
@subsection Edge Accessors

@menu
* dag-draw-edge-from-node::
* dag-draw-edge-to-node::
* dag-draw-edge-weight::
* dag-draw-edge-min-length::
* dag-draw-edge-spline-points::
* dag-draw-edge-attributes::
@end menu

@node dag-draw-edge-from-node
@unnumberedsubsubsec dag-draw-edge-from-node

@lisp
(dag-draw-edge-from-node edge)
@end lisp

Get the source node ID@.

@strong{Returns}: Node ID (symbol or string)

@node dag-draw-edge-to-node
@unnumberedsubsubsec dag-draw-edge-to-node

@lisp
(dag-draw-edge-to-node edge)
@end lisp

Get the destination node ID@.

@strong{Returns}: Node ID (symbol or string)

@node dag-draw-edge-weight
@unnumberedsubsubsec dag-draw-edge-weight

@lisp
(dag-draw-edge-weight edge)
@end lisp

Get the edge weight.

@strong{Returns}: Number (default: 1)

Higher weights make the layout algorithm try harder to keep nodes close together vertically.

@node dag-draw-edge-min-length
@unnumberedsubsubsec dag-draw-edge-min-length

@lisp
(dag-draw-edge-min-length edge)
@end lisp

Get the minimum length constraint.

@strong{Returns}: Integer (default: 1)

Minimum number of ranks between source and destination nodes.

@node dag-draw-edge-spline-points
@unnumberedsubsubsec dag-draw-edge-spline-points

@lisp
(dag-draw-edge-spline-points edge)
@end lisp

Get the Bézier curve control points.

@strong{Returns}: List of (x y) coordinate pairs (after layout), or @code{nil} (before layout)

These points define the smooth curve of the edge in the rendered output.

@node dag-draw-edge-attributes
@unnumberedsubsubsec dag-draw-edge-attributes

@lisp
(dag-draw-edge-attributes edge)
@end lisp

Get the edge's attribute hash table.

@strong{Returns}: Hash table (possibly empty)

@node Rendering Functions
@section Rendering Functions

@menu
* dag-draw-render-graph::
@end menu

@node dag-draw-render-graph
@subsection dag-draw-render-graph

@lisp
(dag-draw-render-graph graph format)
@end lisp

Render a graph to a specific format.

@strong{Arguments}:
@itemize
@item
@code{graph}: The graph to render (must be laid out first)
@item
@code{format}: Output format symbol (@code{'ascii}, @code{'svg}, or @code{'dot})
@end itemize

@strong{Returns}: String containing the rendered output

@strong{Example}:
@lisp
;; ASCII rendering
(setq ascii-output (dag-draw-render-graph graph 'ascii))

;; SVG rendering
(setq svg-output (dag-draw-render-graph graph 'svg))

;; DOT rendering
(setq dot-output (dag-draw-render-graph graph 'dot))
@end lisp

@strong{Error}: Signals an error if the graph hasn't been laid out yet.

@node Configuration Variables
@section Configuration Variables

@menu
* dag-draw-default-node-separation::
* dag-draw-default-rank-separation::
* dag-draw-ascii-node-separation::
* dag-draw-ascii-rank-separation::
* dag-draw-default-output-format::
@end menu

@node dag-draw-default-node-separation
@subsection dag-draw-default-node-separation

Default minimum horizontal separation between nodes.

@strong{Type}: Integer

@strong{Default}: 20

Used when creating graphs in high-resolution mode. Larger values create more spacing.

@strong{Example}:
@lisp
(setq dag-draw-default-node-separation 30)
@end lisp

@node dag-draw-default-rank-separation
@subsection dag-draw-default-rank-separation

Default minimum vertical separation between ranks.

@strong{Type}: Integer

@strong{Default}: 25

Used when creating graphs in high-resolution mode. Larger values create more spacing.

@strong{Example}:
@lisp
(setq dag-draw-default-rank-separation 50)
@end lisp

@node dag-draw-ascii-node-separation
@subsection dag-draw-ascii-node-separation

Horizontal spacing between nodes in ASCII mode (characters).

@strong{Type}: Integer

@strong{Default}: 6

Used when coordinate-mode is @code{'ascii}. This is the number of characters between adjacent nodes.

@strong{Example}:
@lisp
(setq dag-draw-ascii-node-separation 10)
@end lisp

@node dag-draw-ascii-rank-separation
@subsection dag-draw-ascii-rank-separation

Vertical spacing between ranks in ASCII mode (rows).

@strong{Type}: Integer

@strong{Default}: 5

Used when coordinate-mode is @code{'ascii}. This is the number of rows between adjacent ranks.

@strong{Example}:
@lisp
(setq dag-draw-ascii-rank-separation 7)
@end lisp

@node dag-draw-default-output-format
@subsection dag-draw-default-output-format

Default output format for rendered graphs.

@strong{Type}: Symbol (@code{'ascii}, @code{'svg}, or @code{'dot})

@strong{Default}: @code{'svg}

@strong{Example}:
@lisp
(setq dag-draw-default-output-format 'ascii)
@end lisp

@node Graph Structure Accessors
@section Graph Structure Accessors

@menu
* dag-draw-graph-nodes::
* dag-draw-graph-edges::
* dag-draw-graph-node-separation::
* dag-draw-graph-rank-separation::
* dag-draw-graph-coordinate-mode::
@end menu

@node dag-draw-graph-nodes
@subsection dag-draw-graph-nodes

@lisp
(dag-draw-graph-nodes graph)
@end lisp

Get the hash table of nodes.

@strong{Returns}: Hash table mapping node IDs to node structures

@strong{Example}:
@lisp
(setq nodes-table (dag-draw-graph-nodes graph))
(ht-get nodes-table 'my-node)  ; Get a specific node
@end lisp

@node dag-draw-graph-edges
@subsection dag-draw-graph-edges

@lisp
(dag-draw-graph-edges graph)
@end lisp

Get the list of edges.

@strong{Returns}: List of edge structures

@node dag-draw-graph-node-separation
@subsection dag-draw-graph-node-separation

@lisp
(dag-draw-graph-node-separation graph)
@end lisp

Get or set the horizontal node separation for this graph.

@strong{Returns}: Integer

@strong{Settable}: Use @code{setf} to change:
@lisp
(setf (dag-draw-graph-node-separation graph) 30)
@end lisp

@node dag-draw-graph-rank-separation
@subsection dag-draw-graph-rank-separation

@lisp
(dag-draw-graph-rank-separation graph)
@end lisp

Get or set the vertical rank separation for this graph.

@strong{Returns}: Integer

@strong{Settable}: Use @code{setf} to change:
@lisp
(setf (dag-draw-graph-rank-separation graph) 50)
@end lisp

@node dag-draw-graph-coordinate-mode
@subsection dag-draw-graph-coordinate-mode

@lisp
(dag-draw-graph-coordinate-mode graph)
@end lisp

Get or set the coordinate system mode.

@strong{Returns}: Symbol (@code{'ascii} or @code{'high-res})

@strong{Settable}: Use @code{setf} to change:
@lisp
(setf (dag-draw-graph-coordinate-mode graph) 'high-res)
@end lisp

@node Data Structure Details
@section Data Structure Details

@menu
* Node Structure::
* Edge Structure::
* Graph Structure::
@end menu

@node Node Structure
@subsection Node Structure

The @code{dag-draw-node} structure has these slots:

@itemize
@item
@code{id} - Unique identifier (symbol or string)
@item
@code{label} - Display label (string)
@item
@code{x-size} - Width of node bounding box (integer)
@item
@code{y-size} - Height of node bounding box (integer)
@item
@code{x-coord} - X coordinate (number, nil before layout)
@item
@code{y-coord} - Y coordinate (number, nil before layout)
@item
@code{rank} - Assigned rank (integer, nil before layout)
@item
@code{order} - Order within rank (integer, nil before layout)
@item
@code{virtual-p} - Whether this is a virtual node (boolean)
@item
@code{attributes} - Custom attributes (hash table)
@end itemize

@node Edge Structure
@subsection Edge Structure

The @code{dag-draw-edge} structure has these slots:

@itemize
@item
@code{from-node} - Source node ID
@item
@code{to-node} - Destination node ID
@item
@code{weight} - Edge weight (number, default: 1)
@item
@code{min-length} - Minimum length constraint (integer, default: 1)
@item
@code{label} - Optional edge label (string)
@item
@code{spline-points} - Bézier control points (list, nil before layout)
@item
@code{label-position} - Position for edge label (coordinate pair)
@item
@code{attributes} - Custom attributes (hash table)
@end itemize

@node Graph Structure
@subsection Graph Structure

The @code{dag-draw-graph} structure has these slots:

@itemize
@item
@code{nodes} - Hash table mapping IDs to nodes
@item
@code{edges} - List of edge structures
@item
@code{node-separation} - Horizontal spacing (integer)
@item
@code{rank-separation} - Vertical spacing (integer)
@item
@code{max-rank} - Maximum assigned rank (integer, nil before layout)
@item
@code{rank-sets} - User-specified rank constraints (list)
@item
@code{adjusted-positions} - Adjusted coordinates (hash table)
@item
@code{coordinate-mode} - Coordinate system (@code{'ascii} or @code{'high-res})
@item
@code{attributes} - Graph-level attributes (hash table)
@end itemize

@node Troubleshooting
@chapter Troubleshooting

@menu
* Graph has cycles::
* Node not found::
* Nodes overlap in ASCII output::
* Graph looks cramped::
* Graph looks too spread out::
* Must call layout before rendering::
* ASCII output shows broken characters::
* SVG doesn't display in Emacs::
* Performance is slow for large graphs::
* Edges cross when they shouldn't::
@end menu

@node Graph has cycles
@section Graph has cycles

@strong{Error message}:
@example
Error: Graph contains a cycle
@end example

@strong{Problem}: Your graph has a circular dependency (A → B → C → A).

@strong{Solution}: DAGs must be acyclic. Find and remove the edge that creates the cycle.

@strong{How to debug}:
@lisp
;; Manual inspection: print all edges
(dolist (edge (dag-draw-get-edges graph))
  (message "%s -> %s"
           (dag-draw-edge-from-node edge)
           (dag-draw-edge-to-node edge)))

;; Look for cycles in the output
@end lisp

@node Node not found
@section Node not found

@strong{Error message}:
@example
Error: Node 'foo not found in graph
@end example

@strong{Problem}: You're trying to add an edge to a node that doesn't exist.

@strong{Solution}: Add nodes before adding edges that reference them.

@strong{Wrong order}:
@lisp
(dag-draw-add-edge graph 'a 'b)  ; ERROR: nodes don't exist yet
(dag-draw-add-node graph 'a "A")
(dag-draw-add-node graph 'b "B")
@end lisp

@strong{Correct order}:
@lisp
(dag-draw-add-node graph 'a "A")
(dag-draw-add-node graph 'b "B")
(dag-draw-add-edge graph 'a 'b)  ; Now it works
@end lisp

@node Nodes overlap in ASCII output
@section Nodes overlap in ASCII output

@strong{Problem}: Node boxes overlap or text collides in ASCII rendering.

@strong{Solution}: Increase ASCII node separation:

@lisp
(setq dag-draw-ascii-node-separation 10)  ; Default is 6
@end lisp

Or set it per-graph:
@lisp
(setf (dag-draw-graph-node-separation graph) 10)
@end lisp

@node Graph looks cramped
@section Graph looks cramped

@strong{Problem}: Everything is squished together.

@strong{Solution 1}: Increase separation values before layout:

@lisp
;; For ASCII
(setq dag-draw-ascii-node-separation 10)
(setq dag-draw-ascii-rank-separation 7)

;; For high-res/SVG
(setq dag-draw-default-node-separation 40)
(setq dag-draw-default-rank-separation 60)
@end lisp

@strong{Solution 2}: Set per-graph:

@lisp
(setf (dag-draw-graph-node-separation graph) 40)
(setf (dag-draw-graph-rank-separation graph) 60)
(dag-draw-layout-graph graph)  ; Re-layout with new spacing
@end lisp

@node Graph looks too spread out
@section Graph looks too spread out

@strong{Problem}: Too much white space between nodes.

@strong{Solution}: Decrease separation values:

@lisp
;; For ASCII
(setq dag-draw-ascii-node-separation 4)
(setq dag-draw-ascii-rank-separation 3)

;; For high-res/SVG
(setq dag-draw-default-node-separation 15)
(setq dag-draw-default-rank-separation 20)
@end lisp

@node Must call layout before rendering
@section Must call layout before rendering

@strong{Error message}:
@example
Error: Graph must be laid out before rendering
@end example

@strong{Problem}: You called @code{dag-draw-render-graph} without calling @code{dag-draw-layout-graph} first.

@strong{Solution}: Always layout before rendering:

@lisp
;; WRONG
(dag-draw-render-graph graph 'ascii)  ; ERROR

;; RIGHT
(dag-draw-layout-graph graph)
(dag-draw-render-graph graph 'ascii)  ; Works
@end lisp

@node ASCII output shows broken characters
@section ASCII output shows broken characters

@strong{Problem}: Box-drawing characters appear as question marks or broken symbols.

@strong{Solution 1}: Ensure your terminal/buffer supports Unicode:

@lisp
;; Check your buffer encoding
(describe-current-coding-system)

;; Set UTF-8 if needed
(set-buffer-file-coding-system 'utf-8-unix)
@end lisp

@strong{Solution 2}: Use a font that supports box-drawing characters:
@itemize
@item
Courier New
@item
DejaVu Sans Mono
@item
Consolas
@item
Monaco
@item
Any modern monospace font
@end itemize

@node SVG doesn't display in Emacs
@section SVG doesn't display in Emacs

@strong{Problem}: SVG output is generated but doesn't show as an image.

@strong{Cause}: Your Emacs build doesn't have SVG support compiled in.

@strong{Check SVG support}:
@lisp
(image-type-available-p 'svg)  ; Should return t
@end lisp

@strong{Solution}: If it returns @code{nil}, either:
@enumerate
@item
Rebuild Emacs with SVG support (requires librsvg)
@item
Save SVG to a file and view in a web browser:
@end enumerate

@lisp
(with-temp-file "~/graph.svg"
  (insert (dag-draw-render-graph graph 'svg)))
;; Then open graph.svg in Firefox/Chrome
@end lisp

@node Performance is slow for large graphs
@section Performance is slow for large graphs

@strong{Problem}: Layout takes a long time for graphs with many nodes.

@strong{Expected performance}:
@itemize
@item
100 nodes: <1 second
@item
500 nodes: ~5 seconds
@item
1000+ nodes: May take minutes
@end itemize

@strong{Solutions}:

@enumerate
@item
@strong{Simplify the graph}: Combine related nodes
@item
@strong{Remove transitive edges}: If A→B and B→C, you don't need A→C
@item
@strong{Use subgraphs}: Break into smaller related graphs
@item
@strong{Cache layouts}: Layout once, render multiple times
@end enumerate

@lisp
;; Layout once
(dag-draw-layout-graph big-graph)

;; Render multiple times (fast)
(dag-draw-render-graph big-graph 'ascii)
(dag-draw-render-graph big-graph 'svg)
@end lisp

@node Edges cross when they shouldn't
@section Edges cross when they shouldn't

@strong{Problem}: The layout has crossing edges that look messy.

@strong{Explanation}: The GKNV algorithm minimizes crossings using heuristics, but it's not perfect. Some crossings are unavoidable in complex graphs.

@strong{Solutions}:

@enumerate
@item
@strong{Accept it}: Some graphs inherently require crossings
@item
@strong{Adjust edge weights}: Higher weights keep nodes closer
@end enumerate

@lisp
;; Increase weight to pull nodes together
(dag-draw-add-edge graph 'a 'b (ht ("weight" 10)))
@end lisp

@enumerate
@item
@strong{Reorder manually}: Use rank constraints to force certain arrangements
@end enumerate

@lisp
;; Force 'a and 'b on the same rank
(setf (dag-draw-graph-rank-sets graph) '(('a 'b)))
@end lisp

@enumerate
@item
@strong{Simplify}: Fewer nodes and edges = fewer crossings
@end enumerate

@node Advanced Topics
@chapter Advanced Topics

@menu
* Understanding the GKNV Algorithm::
* Custom Renderers::
* Integration Examples::
* Performance Optimization::
* Coordinate Systems::
@end menu

@node Understanding the GKNV Algorithm
@section Understanding the GKNV Algorithm

dag-draw implements the complete GKNV algorithm from the 1993 paper. Understanding the algorithm helps you use the library more effectively.

@menu
* The Four Passes::
* Why This Algorithm?::
@end menu

@node The Four Passes
@subsection The Four Passes

Each pass has a specific job:

@strong{Pass 1: Ranking (Vertical Assignment)}

@strong{Goal}: Assign each node to a vertical level (rank).

@strong{Method}: Network simplex optimization that minimizes total edge length.

@strong{Constraints}:
@itemize
@item
Nodes with no incoming edges get rank 0 (top)
@item
Each edge must go from a lower rank to a higher rank
@item
Minimize the sum of edge lengths
@end itemize

@strong{User control}: You can force nodes onto the same rank with @code{rank-sets}.

@strong{Pass 2: Ordering (Horizontal Arrangement)}

@strong{Goal}: Within each rank, arrange nodes left-to-right to minimize edge crossings.

@strong{Method}: Weighted median heuristic with local transposition.

@strong{Why it's hard}: This is an NP-complete problem. The algorithm uses heuristics that work well in practice but don't guarantee optimal results.

@strong{User control}: Limited. The algorithm decides the order automatically.

@strong{Pass 3: Positioning (Coordinate Assignment)}

@strong{Goal}: Calculate exact X,Y coordinates for each node.

@strong{Method}: Constructs an auxiliary graph and runs another network simplex optimization.

@strong{Constraints}:
@itemize
@item
Respect the ordering from Pass 2
@item
Maintain minimum separation between nodes
@item
Align edges nicely when possible
@end itemize

@strong{User control}: Adjust separation values before layout.

@strong{Pass 4: Splines (Edge Drawing)}

@strong{Goal}: Generate smooth Bézier curves for edges.

@strong{Method}: Calculates control points that route edges around nodes.

@strong{Result}: Professional-looking curves that avoid overlapping nodes.

@strong{User control}: None. This is purely algorithmic.

@node Why This Algorithm?
@subsection Why This Algorithm?

Other layout algorithms exist (force-directed, circular, etc.), but GKNV is optimal for hierarchical DAGs because:

@enumerate
@item
@strong{Respects hierarchy}: Graphs flow in a consistent direction
@item
@strong{Minimizes crossings}: Uses sophisticated heuristics proven in practice
@item
@strong{Fast}: Polynomial time complexity handles large graphs
@item
@strong{Extensible}: Each pass can be customized independently
@end enumerate

@node Custom Renderers
@section Custom Renderers

You can create custom renderers for new output formats.

@menu
* Renderer Interface::
* Accessing Layout Information::
* Example Simple Text Renderer::
@end menu

@node Renderer Interface
@subsection Renderer Interface

A renderer is a function that takes a graph and returns a string:

@lisp
(defun my-custom-renderer (graph)
  "Render GRAPH to my custom format."
  ;; Access laid-out nodes
  (let ((nodes (ht-values (dag-draw-graph-nodes graph)))
        (edges (dag-draw-graph-edges graph)))
    ;; Generate output based on node coordinates and edge splines
    (my-format-output nodes edges)))
@end lisp

@node Accessing Layout Information
@subsection Accessing Layout Information

After layout, each node has coordinates:

@lisp
(defun print-node-positions (graph)
  "Print all node positions."
  (ht-each
   (lambda (id node)
     (message "Node %s: (%d, %d)"
              id
              (dag-draw-node-x-coord node)
              (dag-draw-node-y-coord node)))
   (dag-draw-graph-nodes graph)))
@end lisp

And each edge has spline points:

@lisp
(defun print-edge-curves (graph)
  "Print all edge spline points."
  (dolist (edge (dag-draw-graph-edges graph))
    (message "Edge %s -> %s: %S"
             (dag-draw-edge-from-node edge)
             (dag-draw-edge-to-node edge)
             (dag-draw-edge-spline-points edge))))
@end lisp

@node Example Simple Text Renderer
@subsection Example: Simple Text Renderer

@lisp
(defun dag-draw-render-simple-text (graph)
  "Simple text-only renderer (no graphics)."
  (let ((output ""))
    ;; List nodes by rank
    (ht-each
     (lambda (id node)
       (setq output
             (concat output
                     (format "Node %s (rank %d, order %d): %s\n"
                             id
                             (dag-draw-node-rank node)
                             (dag-draw-node-order node)
                             (dag-draw-node-label node)))))
     (dag-draw-graph-nodes graph))

    ;; List edges
    (setq output (concat output "\nEdges:\n"))
    (dolist (edge (dag-draw-graph-edges graph))
      (setq output
            (concat output
                    (format "  %s -> %s\n"
                            (dag-draw-edge-from-node edge)
                            (dag-draw-edge-to-node edge)))))
    output))
@end lisp

@node Integration Examples
@section Integration Examples

@menu
* With Org Mode::
* With Project Management::
@end menu

@node With Org Mode
@subsection With Org Mode

Generate graphs from org-mode data:

@lisp
(defun org-visualize-dependencies ()
  "Visualize current subtree's task dependencies."
  (interactive)
  (let ((graph (dag-draw-create-graph))
        (tasks '()))
    ;; Collect tasks from current subtree
    (org-map-entries
     (lambda ()
       (let ((id (org-id-get-create))
             (heading (org-get-heading t t t t)))
         (dag-draw-add-node graph (intern id) heading)
         (push (cons id heading) tasks)))
     nil 'tree)

    ;; Add edges based on org-edna dependencies
    ;; (simplified example)
    (org-map-entries
     (lambda ()
       (let ((id (org-id-get))
             (deps (org-entry-get nil "BLOCKER")))
         (when deps
           (dolist (dep (split-string deps))
             (dag-draw-add-edge graph (intern dep) (intern id))))))
     nil 'tree)

    ;; Layout and display
    (dag-draw-layout-graph graph)
    (with-current-buffer (get-buffer-create "*Task Dependencies*")
      (erase-buffer)
      (insert (dag-draw-render-graph graph 'ascii))
      (pop-to-buffer (current-buffer)))))
@end lisp

@node With Project Management
@subsection With Project Management

Track project dependencies:

@lisp
(defvar my-project-tasks
  '((requirements . "Requirements")
    (design . "Design")
    (coding . "Coding")
    (testing . "Testing")
    (deploy . "Deployment"))
  "Project tasks.")

(defvar my-project-dependencies
  '((requirements design)
    (design coding)
    (coding testing)
    (testing deploy))
  "Task dependencies as (from to) pairs.")

(defun visualize-project ()
  "Show project task dependencies."
  (interactive)
  (let ((graph (dag-draw-create-graph)))
    ;; Add tasks as nodes
    (dolist (task my-project-tasks)
      (dag-draw-add-node graph (car task) (cdr task)))

    ;; Add dependencies as edges
    (dolist (dep my-project-dependencies)
      (dag-draw-add-edge graph (car dep) (cadr dep)))

    ;; Layout and render
    (dag-draw-layout-graph graph)
    (message "%s" (dag-draw-render-graph graph 'ascii))))
@end lisp

@node Performance Optimization
@section Performance Optimization

@menu
* Caching Layouts::
* Incremental Updates::
@end menu

@node Caching Layouts
@subsection Caching Layouts

If you render the same graph multiple times, layout once:

@lisp
;; Expensive (layouts every time)
(dotimes (i 10)
  (dag-draw-layout-graph graph)
  (dag-draw-render-graph graph 'ascii))

;; Efficient (layouts once)
(dag-draw-layout-graph graph)
(dotimes (i 10)
  (dag-draw-render-graph graph 'ascii))
@end lisp

@node Incremental Updates
@subsection Incremental Updates

For dynamic graphs that change frequently, consider:

@enumerate
@item
Keep the graph structure
@item
Modify only what changed
@item
Re-layout when needed
@item
Render on demand
@end enumerate

@lisp
(defvar my-dynamic-graph (dag-draw-create-graph))

(defun add-task (id label &optional deps)
  "Add a task to the dynamic graph."
  (dag-draw-add-node my-dynamic-graph id label)
  (dolist (dep deps)
    (dag-draw-add-edge my-dynamic-graph dep id)))

(defun show-current-graph ()
  "Display the current state."
  (dag-draw-layout-graph my-dynamic-graph)
  (message "%s" (dag-draw-render-graph my-dynamic-graph 'ascii)))

;; Use it
(add-task 'start "Start")
(add-task 'middle "Middle" '(start))
(add-task 'end "End" '(middle))
(show-current-graph)
@end lisp

@node Coordinate Systems
@section Coordinate Systems

dag-draw supports two coordinate systems:

@menu
* ASCII Mode (Default)::
* High-Resolution Mode::
* When to Use Which::
@end menu

@node ASCII Mode (Default)
@subsection ASCII Mode (Default)

Optimized for character grid output:
@itemize
@item
Uses smaller separation values
@item
Coordinates are integers
@item
Designed for 80-column terminals
@end itemize

@lisp
(setf (dag-draw-graph-coordinate-mode graph) 'ascii)
@end lisp

@node High-Resolution Mode
@subsection High-Resolution Mode

Optimized for SVG and detailed graphics:
@itemize
@item
Uses larger separation values
@item
Coordinates are floats
@item
Designed for scalable output
@end itemize

@lisp
(setf (dag-draw-graph-coordinate-mode graph) 'high-res)
@end lisp

@node When to Use Which
@subsection When to Use Which

@strong{Use ASCII mode when}:
@itemize
@item
Primarily rendering to ASCII
@item
Terminal output
@item
Want compact layout
@item
Working with small graphs
@end itemize

@strong{Use high-res mode when}:
@itemize
@item
Primarily rendering to SVG
@item
Need precise positioning
@item
Creating publication-quality output
@item
Large graphs with many nodes
@end itemize

@node Contributing
@chapter Contributing

@menu
* Development Setup::
* Testing::
* Code Style::
* Pull Requests::
* Reporting Bugs::
@end menu

@node Development Setup
@section Development Setup

Clone the repository:

@example
git clone https://github.com/example/dag-draw.el.git
cd dag-draw.el
@end example

Install development dependencies:

@example
eldev test  # Runs test suite
@end example

@node Testing
@section Testing

dag-draw uses Test-Driven Development with Buttercup:

@example
# Run all tests
eldev test

# Run specific test file
eldev test test/dag-draw-core-test.el

# Run with debugging output
eldev -dtT test
@end example

@node Code Style
@section Code Style

@itemize
@item
Follow standard Emacs Lisp conventions
@item
Use @code{lexical-binding: t}
@item
Document all public functions with docstrings
@item
Keep functions small and focused
@item
Write tests before implementation
@end itemize

@node Pull Requests
@section Pull Requests

@enumerate
@item
Fork the repository
@item
Create a feature branch
@item
Write tests that fail
@item
Implement the feature
@item
Ensure all tests pass
@item
Submit a pull request
@end enumerate

@node Reporting Bugs
@section Reporting Bugs

File issues at: @uref{https://github.com/example/dag-draw.el/issues}

Include:
@itemize
@item
Emacs version (@code{M-x emacs-version})
@item
dag-draw version
@item
Minimal reproduction case
@item
Expected vs actual behavior
@end itemize

@node Index
@chapter Index

@printindex cp

@node Function Index
@chapter Function Index

@printindex fn

@node Variable Index
@chapter Variable Index

@printindex vr

@bye
