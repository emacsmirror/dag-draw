;;; dag-draw-render.el --- Graph rendering for dag-draw -*- lexical-binding: t -*-

;; Copyright (C) 2024

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;;; Commentary:

;; Implementation of graph rendering in multiple formats: SVG, ASCII art, and DOT.
;; This module takes positioned graphs from the layout algorithm and converts them
;; into visual representations with nodes, edges, and labels.

;;; Code:

(require 'dash)
(require 'ht)
(require 'dag-draw)
(require 'dag-draw-core)
(require 'dag-draw-splines)

;;; Customization

(defgroup dag-draw-render nil
  "Rendering options for dag-draw graphs."
  :group 'dag-draw
  :prefix "dag-draw-render-")

(defcustom dag-draw-render-svg-node-fill "#f0f0f0"
  "Default fill color for SVG nodes."
  :type 'string
  :group 'dag-draw-render)

(defcustom dag-draw-render-svg-node-stroke "#000000"
  "Default stroke color for SVG nodes."
  :type 'string
  :group 'dag-draw-render)

(defcustom dag-draw-render-svg-edge-stroke "#666666"
  "Default stroke color for SVG edges."
  :type 'string
  :group 'dag-draw-render)

(defcustom dag-draw-render-ascii-grid-scale 2
  "Scale factor for ASCII grid density (higher = more detailed)."
  :type 'integer
  :group 'dag-draw-render)

;;; SVG Rendering

(defun dag-draw-render-svg (graph)
  "Render GRAPH as SVG string with positioned nodes and smooth spline edges."
  (let* ((bounds (dag-draw-get-graph-bounds graph))
         (min-x (nth 0 bounds))
         (min-y (nth 1 bounds))
         (max-x (nth 2 bounds))
         (max-y (nth 3 bounds))
         (width (- max-x min-x))
         (height (- max-y min-y))
         (margin 20)
         (svg-width (+ width (* 2 margin)))
         (svg-height (+ height (* 2 margin))))
    
    (concat
     (dag-draw--svg-header svg-width svg-height (- min-x margin) (- min-y margin) width height)
     (dag-draw--svg-defs)
     (dag-draw--svg-render-edges graph)
     (dag-draw--svg-render-nodes graph)
     (dag-draw--svg-footer))))

(defun dag-draw--svg-header (svg-width svg-height view-x view-y view-width view-height)
  "Generate SVG header with dimensions and viewBox."
  (format "<svg width=\"%.1f\" height=\"%.1f\" viewBox=\"%.1f %.1f %.1f %.1f\" xmlns=\"http://www.w3.org/2000/svg\">\n"
          svg-width svg-height view-x view-y view-width view-height))

(defun dag-draw--svg-defs ()
  "Generate SVG definitions for arrow markers and styles."
  (concat
   "  <defs>\n"
   "    <marker id=\"arrowhead\" markerWidth=\"10\" markerHeight=\"7\" refX=\"9\" refY=\"3.5\" orient=\"auto\">\n"
   "      <polygon points=\"0 0, 10 3.5, 0 7\" fill=\"" dag-draw-render-svg-edge-stroke "\" />\n"
   "    </marker>\n"
   "    <style><![CDATA[\n"
   "      .node { fill: " dag-draw-render-svg-node-fill "; stroke: " dag-draw-render-svg-node-stroke "; stroke-width: 1; }\n"
   "      .node-label { font-family: Arial, sans-serif; font-size: 12px; text-anchor: middle; dominant-baseline: central; }\n"
   "      .edge { fill: none; stroke: " dag-draw-render-svg-edge-stroke "; stroke-width: 2; marker-end: url(#arrowhead); }\n"
   "      .edge-label { font-family: Arial, sans-serif; font-size: 10px; text-anchor: middle; }\n"
   "    ]]></style>\n"
   "  </defs>\n"))

(defun dag-draw--svg-render-nodes (graph)
  "Render all nodes as SVG rectangles with labels."
  (let ((node-svg "  <g class=\"nodes\">\n"))
    (ht-each (lambda (node-id node)
               (let* ((x (or (dag-draw-node-x-coord node) 0))
                      (y (or (dag-draw-node-y-coord node) 0))
                      (width (dag-draw-node-x-size node))
                      (height (dag-draw-node-y-size node))
                      (label (dag-draw-node-label node))
                      (rect-x (- x (/ width 2.0)))
                      (rect-y (- y (/ height 2.0))))
                 
                 (setq node-svg
                       (concat node-svg
                               (format "    <rect class=\"node\" x=\"%.1f\" y=\"%.1f\" width=\"%.1f\" height=\"%.1f\" rx=\"3\" />\n"
                                       rect-x rect-y width height)
                               (format "    <text class=\"node-label\" x=\"%.1f\" y=\"%.1f\">%s</text>\n"
                                       x y (dag-draw--escape-xml label))))))
             (dag-draw-graph-nodes graph))
    
    (concat node-svg "  </g>\n")))

(defun dag-draw--svg-render-edges (graph)
  "Render all edges as SVG paths with smooth splines."
  (let ((edge-svg "  <g class=\"edges\">\n"))
    (dolist (edge (dag-draw-graph-edges graph))
      (when (dag-draw-edge-spline-points edge)
        (let ((path-data (dag-draw--svg-path-from-spline edge)))
          (setq edge-svg
                (concat edge-svg
                        (format "    <path class=\"edge\" d=\"%s\" />\n" path-data)))
          
          ;; Add edge label if present
          (when (dag-draw-edge-label edge)
            (let ((label-pos (dag-draw-edge-label-position edge)))
              (when label-pos
                (setq edge-svg
                      (concat edge-svg
                              (format "    <text class=\"edge-label\" x=\"%.1f\" y=\"%.1f\">%s</text>\n"
                                      (dag-draw-point-x label-pos)
                                      (dag-draw-point-y label-pos)
                                      (dag-draw--escape-xml (dag-draw-edge-label edge)))))))))))
    
    (concat edge-svg "  </g>\n")))

(defun dag-draw--svg-path-from-spline (edge)
  "Convert edge spline points to SVG path data."
  (let ((points (dag-draw-edge-spline-points edge)))
    (when points
      (let ((path-data (format "M %.1f,%.1f"
                              (dag-draw-point-x (car points))
                              (dag-draw-point-y (car points)))))
        
        ;; Add line segments for all remaining points
        (dolist (point (cdr points))
          (setq path-data
                (concat path-data
                        (format " L %.1f,%.1f"
                                (dag-draw-point-x point)
                                (dag-draw-point-y point)))))
        
        path-data))))

(defun dag-draw--svg-footer ()
  "Generate SVG footer."
  "</svg>\n")

(defun dag-draw--escape-xml (text)
  "Escape XML special characters in TEXT."
  (replace-regexp-in-string
   "&" "&amp;"
   (replace-regexp-in-string
    "<" "&lt;"
    (replace-regexp-in-string
     ">" "&gt;"
     (replace-regexp-in-string
      "\"" "&quot;"
      (replace-regexp-in-string "'" "&apos;" text))))))

;;; ASCII Art Rendering

(defun dag-draw-render-ascii (graph)
  "Render GRAPH as ASCII art with box-drawing characters."
  (let* ((bounds (dag-draw-get-graph-bounds graph))
         (min-x (nth 0 bounds))
         (min-y (nth 1 bounds))
         (max-x (nth 2 bounds))
         (max-y (nth 3 bounds))
         (scale dag-draw-render-ascii-grid-scale)
         (grid-width (ceiling (* (- max-x min-x) scale (/ 1.0 10))))
         (grid-height (ceiling (* (- max-y min-y) scale (/ 1.0 10))))
         (grid (dag-draw--create-ascii-grid grid-width grid-height)))
    
    ;; Draw nodes
    (dag-draw--ascii-draw-nodes graph grid min-x min-y scale)
    
    ;; Draw edges
    (dag-draw--ascii-draw-edges graph grid min-x min-y scale)
    
    ;; Convert grid to string
    (dag-draw--ascii-grid-to-string grid)))

(defun dag-draw--create-ascii-grid (width height)
  "Create empty ASCII grid of given WIDTH and HEIGHT."
  (let ((grid (make-vector height nil)))
    (dotimes (y height)
      (aset grid y (make-vector width ?\s)))  ; Fill with spaces
    grid))

(defun dag-draw--ascii-draw-nodes (graph grid min-x min-y scale)
  "Draw nodes on ASCII grid."
  (ht-each (lambda (node-id node)
             (let* ((x (or (dag-draw-node-x-coord node) 0))
                    (y (or (dag-draw-node-y-coord node) 0))
                    (width (dag-draw-node-x-size node))
                    (height (dag-draw-node-y-size node))
                    (label (dag-draw-node-label node))
                    (grid-x (floor (* (- x min-x) scale (/ 1.0 10))))
                    (grid-y (floor (* (- y min-y) scale (/ 1.0 10))))
                    (grid-width (max 3 (ceiling (* width scale (/ 1.0 20)))))
                    (grid-height (max 3 (ceiling (* height scale (/ 1.0 20))))))
               
               (dag-draw--ascii-draw-box grid grid-x grid-y grid-width grid-height label)))
           (dag-draw-graph-nodes graph)))

(defun dag-draw--ascii-draw-box (grid x y width height label)
  "Draw a box with LABEL on ASCII grid at position (X,Y) with given WIDTH and HEIGHT."
  (let* ((grid-height (length grid))
         (grid-width (if (> grid-height 0) (length (aref grid 0)) 0)))
    
    ;; Draw top edge
    (when (and (>= y 0) (< y grid-height))
      (when (and (>= x 0) (< x grid-width))
        (aset (aref grid y) x ?┌))
      (dotimes (i (- width 2))
        (let ((pos-x (+ x i 1)))
          (when (and (>= pos-x 0) (< pos-x grid-width))
            (aset (aref grid y) pos-x ?─))))
      (let ((pos-x (+ x width -1)))
        (when (and (>= pos-x 0) (< pos-x grid-width))
          (aset (aref grid y) pos-x ?┐))))
    
    ;; Draw sides and fill
    (dotimes (i (- height 2))
      (let ((pos-y (+ y i 1)))
        (when (and (>= pos-y 0) (< pos-y grid-height))
          (when (and (>= x 0) (< x grid-width))
            (aset (aref grid pos-y) x ?│))
          (let ((pos-x (+ x width -1)))
            (when (and (>= pos-x 0) (< pos-x grid-width))
              (aset (aref grid pos-y) pos-x ?│))))))
    
    ;; Draw bottom edge
    (let ((pos-y (+ y height -1)))
      (when (and (>= pos-y 0) (< pos-y grid-height))
        (when (and (>= x 0) (< x grid-width))
          (aset (aref grid pos-y) x ?└))
        (dotimes (i (- width 2))
          (let ((pos-x (+ x i 1)))
            (when (and (>= pos-x 0) (< pos-x grid-width))
              (aset (aref grid pos-y) pos-x ?─))))
        (let ((pos-x (+ x width -1)))
          (when (and (>= pos-x 0) (< pos-x grid-width))
            (aset (aref grid pos-y) pos-x ?┘)))))
    
    ;; Draw label in center if it fits (need at least 4x3 box for any text)
    (when (and label (>= width 4) (>= height 3))
      (let* ((label-len (length label))
             (label-x (+ x (/ (- width label-len) 2)))
             (label-y (+ y (/ height 2))))
        (when (and (>= label-y 0) (< label-y grid-height)
                   (>= label-x 0) (< (+ label-x label-len) grid-width))
          (dotimes (i (min label-len (- width 2)))
            (let ((char-x (+ label-x i)))
              (when (and (>= char-x 0) (< char-x grid-width))
                (aset (aref grid label-y) char-x (aref label i))))))))))

(defun dag-draw--ascii-draw-edges (graph grid min-x min-y scale)
  "Draw edges on ASCII grid using simple line characters."
  (dolist (edge (dag-draw-graph-edges graph))
    (let* ((from-node (dag-draw-get-node graph (dag-draw-edge-from-node edge)))
           (to-node (dag-draw-get-node graph (dag-draw-edge-to-node edge)))
           (from-x (floor (* (- (or (dag-draw-node-x-coord from-node) 0) min-x) scale (/ 1.0 10))))
           (from-y (floor (* (- (or (dag-draw-node-y-coord from-node) 0) min-y) scale (/ 1.0 10))))
           (to-x (floor (* (- (or (dag-draw-node-x-coord to-node) 0) min-x) scale (/ 1.0 10))))
           (to-y (floor (* (- (or (dag-draw-node-y-coord to-node) 0) min-y) scale (/ 1.0 10)))))
      
      ;; Simple straight line for now (could be enhanced with spline routing)
      (dag-draw--ascii-draw-line grid from-x from-y to-x to-y))))

(defun dag-draw--ascii-draw-line (grid x1 y1 x2 y2)
  "Draw a simple line from (X1,Y1) to (X2,Y2) on ASCII grid."
  (let* ((grid-height (length grid))
         (grid-width (if (> grid-height 0) (length (aref grid 0)) 0))
        (dx (- x2 x1))
        (dy (- y2 y1)))
    
    (cond
     ;; Horizontal line
     ((= dy 0)
      (let ((start-x (min x1 x2))
            (end-x (max x1 x2)))
        (dotimes (i (1+ (- end-x start-x)))
          (let ((x (+ start-x i)))
            (when (and (>= x 0) (< x grid-width)
                       (>= y1 0) (< y1 grid-height))
              (aset (aref grid y1) x ?─))))))
     
     ;; Vertical line
     ((= dx 0)
      (let ((start-y (min y1 y2))
            (end-y (max y1 y2)))
        (dotimes (i (1+ (- end-y start-y)))
          (let ((y (+ start-y i)))
            (when (and (>= x1 0) (< x1 grid-width)
                       (>= y 0) (< y grid-height))
              (aset (aref grid y) x1 ?│))))))
     
     ;; L-shaped line (horizontal then vertical)
     (t
      ;; Draw horizontal segment first
      (dag-draw--ascii-draw-line grid x1 y1 x2 y1)
      ;; Draw vertical segment  
      (dag-draw--ascii-draw-line grid x2 y1 x2 y2)))))
          (let ((x (+ x1 (/ (* i dx) steps)))
                (y (+ y1 (/ (* i dy) steps))))
            (setq x (floor x))
            (setq y (floor y))
            (when (and (>= x 0) (< x grid-width)
                       (>= y 0) (< y grid-height))
              (let ((char (cond
                          ((> (abs dx) (abs dy)) ?─)  ; More horizontal
                          ((> (abs dy) (abs dx)) ?│)  ; More vertical
                          (t ?┼))))                   ; Diagonal
                (aset (aref grid y) x char))))))))))

(defun dag-draw--ascii-grid-to-string (grid)
  "Convert ASCII grid to string representation."
  (mapconcat (lambda (row)
               (string-trim-right (apply #'string (append row nil))))
             grid
             "\n"))

;;; DOT Format Rendering

(defun dag-draw-render-dot (graph)
  "Render GRAPH in Graphviz DOT format."
  (let ((dot-output "digraph G {\n")
        (node-attrs "  node [shape=box, style=filled, fillcolor=lightgray];\n")
        (edge-attrs "  edge [color=black];\n"))
    
    ;; Add graph attributes
    (setq dot-output (concat dot-output node-attrs edge-attrs "\n"))
    
    ;; Add nodes
    (ht-each (lambda (node-id node)
               (let ((label (dag-draw-node-label node)))
                 (setq dot-output
                       (concat dot-output
                               (format "  %s [label=\"%s\"];\n"
                                       (symbol-name node-id)
                                       (dag-draw--escape-dot-string label))))))
             (dag-draw-graph-nodes graph))
    
    ;; Add edges
    (setq dot-output (concat dot-output "\n"))
    (dolist (edge (dag-draw-graph-edges graph))
      (let ((from (symbol-name (dag-draw-edge-from-node edge)))
            (to (symbol-name (dag-draw-edge-to-node edge)))
            (label (dag-draw-edge-label edge)))
        (setq dot-output
              (concat dot-output
                      (format "  %s -> %s" from to)
                      (if label
                          (format " [label=\"%s\"]" (dag-draw--escape-dot-string label))
                        "")
                      ";\n"))))
    
    (concat dot-output "}\n")))

(defun dag-draw--escape-dot-string (text)
  "Escape special characters for DOT format."
  (replace-regexp-in-string
   "\"" "\\\\\""
   (replace-regexp-in-string "\\\\" "\\\\\\\\" text)))

;;; Utility functions

(defun dag-draw-save-to-file (graph filename &optional format)
  "Save rendered GRAPH to FILENAME in specified FORMAT."
  (let* ((output-format (or format
                           (cond
                            ((string-match "\\.svg$" filename) 'svg)
                            ((string-match "\\.dot$" filename) 'dot)
                            ((string-match "\\.txt$" filename) 'ascii)
                            (t dag-draw-default-output-format))))
         (content (dag-draw-render-graph graph output-format)))
    
    (with-temp-file filename
      (insert content))
    
    (message "Graph saved to %s (%s format)" filename output-format)))

(defun dag-draw-display-in-buffer (graph &optional buffer-name format)
  "Display rendered GRAPH in a buffer."
  (let* ((buffer (get-buffer-create (or buffer-name "*DAG Draw*")))
         (output-format (or format 'ascii))
         (content (dag-draw-render-graph graph output-format)))
    
    (with-current-buffer buffer
      (erase-buffer)
      (insert content)
      (goto-char (point-min))
      
      ;; Set appropriate mode
      (cond
       ((eq output-format 'svg)
        (when (fboundp 'nxml-mode) (nxml-mode)))
       ((eq output-format 'dot)
        (when (fboundp 'graphviz-dot-mode) (graphviz-dot-mode)))
       (t
        (text-mode))))
    
    (display-buffer buffer)
    buffer))

(provide 'dag-draw-render)

;;; dag-draw-render.el ends here